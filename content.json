{"meta":{"title":"Gunner","subtitle":"Gunner","description":"My Tech Blog","author":"SuHawn Yun","url":"http://xyom.github.io"},"pages":[],"posts":[{"title":"프로젝트 관련 질문","slug":"면접( 프로젝트 관련 질문)","date":"2017-12-08T08:47:39.918Z","updated":"2017-12-08T08:47:39.918Z","comments":true,"path":"2017/12/08/면접( 프로젝트 관련 질문)/","link":"","permalink":"http://xyom.github.io/2017/12/08/면접( 프로젝트 관련 질문)/","excerpt":"","text":"프로젝트 관련 질문**만약 해보지 않았던 거라도 지금 내가 알고있는 것으로 지금이라면 어떻게 하겠다고 이야기 하기. 왜 Node js를 사용하였나?? -&gt; 과거에는 각 api를 하나의 jsp 파일로 만들어서 처리하였다. 이는 매우 불편하고 생산성이 떨어졌고 Node js를 사용하면서 생산성이 많이 향상되었다. 또 npm으로 모듈을 쉽게 관리할 수 있었고 single thread에서 비동기 이벤트 방식으로 동작하기 때문에 멀티 쓰레드에서의 복잡한 동기 문제에 대해 덜 신경쓸 수 있었다. -&gt; Node js는 Cpu Bound 작업에 약하다. single thread가 모두 처리하기 때문에 한 작업이 길어질 경우 다른 작업을 처리하지 못해 반환 시간이 길어지게 된다. -&gt; 작업을 나누어 setTimeout을 통해 일정시간 뒤에 작업을 넣는 방식으로 처리하면 이런 문제를 극복할 수 있다. ​ 비동기 처리를 하다보면 Callback hell 문제가 발생할 수 있는데 이를 어떻게 해결할 수 있나?? 프로젝트 당시 이 문제를 만났을 때는 waterfall이라는 라이브러리를 사용하였고 이는 내부적으로 promise로 구현된 것으로 알고 있다. ​ *서비스 규모가 커질 경우에 대해 생각해보았나 -&gt; 서비스 규모가 커지면 요청이 많이 발생해서 Cpu 사용량도 증가하고 DB나 네트워크 I/O도 매우 커질 것이다. 서버가 많은 요구 사항을 처리하다 보면 에러가 일어날 수 있기 때문에 이 일련의 과정을 트랜잭션으로 처리하는 것은 필수 인 것 같다. 그리고 서버 작업을 하면서 Node js로 프로그래밍 하다보니 AWS 상에서 작업해야 할 경우가 많이 생겼다. 단순히 Putty에서 vi를 통해 코딩하는 것은 어려움이 있어서 WebStorm을 이용하여 sftp로 원격접속하여 편집하였다. 팀 프로젝트를 하면서 어려웠던 점이 없었나? -&gt; 서버 개발, 클라이언트 개발을 나누어 하다보니 api의 요청 값과 응답 값들에 대해서 서로 맞추는게 어려웠다. 그래서 PostMan을 이용해서 작성한뒤 문서를 공유했다. TCP/UDP -&gt; TCP는 신뢰성, UDP는 비신뢰성, TCP는 신뢰성 있는 통신을 하기 위해서 handshaking과 흐름제어 , 오류제어를 한다. 그리고 TCP는 네트워크의 과부하를 막기 위해서 혼잡제어도 사용한다.","categories":[{"name":"InterView","slug":"InterView","permalink":"http://xyom.github.io/categories/InterView/"}],"tags":[{"name":"InterView","slug":"InterView","permalink":"http://xyom.github.io/tags/InterView/"}]},{"title":"Node js 동작 원리","slug":"Node js 동작 원리","date":"2017-12-08T08:47:39.898Z","updated":"2017-12-08T08:47:39.898Z","comments":true,"path":"2017/12/08/Node js 동작 원리/","link":"","permalink":"http://xyom.github.io/2017/12/08/Node js 동작 원리/","excerpt":"","text":"Node js 동작 원리 Index1. Node js 란?2. Node js 동작 원리 1. Node js란?Node js 는 구글의 크롬 V8 자바스크립트 엔진을 기반으로 한 고성능 네트워크 서버이다. Single Thread 기반의 Event Loop를 기반으로 하고 있으며 File, Network 등에 대해서 비동기 IO 처리를 하는 서버 미들웨어이다. 또한 Single Thread 이벤트 기반이기 때문에 Multi Thread 프로그래밍에서의 가장 큰 문제점인 자원에 대한 동시접근 문제가 발생하지는 않는다. -&gt; 자원의 접근 순서는 보장할 수 없다.Node js가 Single Thread 기반이기 때문에 Spring과 같은 Multi Thread 방식을 채택하는 서버 프레임워크보다 Context Switching이 적어 빠르다는 것은 맞지 않는 말이라고 한다.Node js 또한 I/O처리에서 내부적으로는 libio의 Thread Pool에 의해 동작하기 때문에 Node js 또한 Disk , DB 접근이 많은 작업에 대해서는 유리하지 않으며 오히려 Servlet이 빠르다고 한다. -&gt; Node js는 I/O 작업이 적은 메시징 작업에서 유리하다.Node js는 JavaScript를 기반으로 하기 때문에 프론트 개발자가 서버까지 개발할 수 있다는 장점과 JSON 사용, npm을 통한 모듈 관리등을 장점으로 하기 때문에 생산성에 대한 부분에서도 상당히 높다.또한 현재 Http 통신에 있어서 JSON 형식을 사용한 데이터 전송이 많아지고 있는데 Node js를 사용하게 되면 이 부분에 대한 코드의 양도 적어지고 다루기가 쉬워진다.Node js가 인기 있는 이유는 수준 높은 실력을 필요로 하던 백엔드 개발에 대해 진입장벽을 낮추어 프론트 엔트의 개발자 또한 빠르게 개발할 수 있다는 것이다. 그리고 node js의 모듈중의 하나인 socket.io는 HTML5의 WebSocket의 단점을 보완해 준다.HTML 5의 웹소켓이 좋은 기술이지만 웹소켓은 브라우져 호환성의 문제가 있다. Socket.io는 웹소켓을 포함해 롱 폴링, 스트림 등의 방식을 모두 추상화 하였기 때문에 브라우져에 상관없이 Socket.io를 통해 푸쉬를 구현할 수 있게 해준다.Node js는 단점 또한 가지고 있는데 하나의 작업 자체가 시간이 많이 걸리면 전체 시스템의 성능이 아주 급격하게 떨어진다. 그래서 CPU bound가 낮은 작업 위주로 개발이 되어야 한다. -&gt; 만약 많은 CPU bound를 가지는 작업이 생긴다면 이를 분할하여 SetTimeOut() 함수 호출을 통해 이벤트 큐에 분할로 넣어주는 방식으로 처리할 수 있다.또한 Node js는 비동기 처리를 기본으로 하기 때문에 여기서 오는 Callback 함수의 중첩(Callback hell) 에 대한 문제도 생긴다. -&gt; waterfall과 같은 라이브러리를 사용해 어느정도 해결할 수 있다.####### 원문 http://bcho.tistory.com/876 2. Node js 동작 원리 Node Js는 기본적으로 V8엔진을 통해 Single Thread로 동작하게 된다. 하지만 Node js의 특성상 비동기식 I/O를 채택하고 있기 때문에 어떠한 I/O가 발생하게 되면 libio의 ThreadPool에 작업을 전달하게 되고 I/O가 완료되게 되면 EventQueue에 CallBack 함수가 쌓이게 된다.1234connection.query('insert into table values('2','3')', function(result,err)&#123; console.log(result);&#125;); 만약 위와 같이 DB Connection을 통해 DB에 쿼리를 날리는 경우가 발생하면 ‘insert ‘문에 대한 DB IO가 발생하게 된다. Node js는 이 작업에 대해 완료될 때 까지 기다리지 않고 다른 작업을 처리하고 있다가 I/O가 완료되면 callback 함수를 EventQueue에 집어 넣는다. EventLoop는 항상 돌고 있다가 V8 엔진의 호출스택이 모두 종료(모든 작업을 실행하고 남아 있는 작업이 없을 경우) EventQueue에서 작업을 꺼내어 처리하게 된다.또한 Node js가 ThreadPool을 사용하는 이유중에 하나는 시스템에서 Non blocking을 지원하지 않아 Blocking이 발생하는 함수에 대해 호출이 일어났을 경우 이를 Thread에 할당해 처리한뒤 i/o작업이끝나면 callback을 리턴해주어 non blocking처럼 작동할 수 있도록 한다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://xyom.github.io/categories/Programming/"},{"name":"Node js","slug":"Programming/Node-js","permalink":"http://xyom.github.io/categories/Programming/Node-js/"}],"tags":[{"name":"Node js","slug":"Node-js","permalink":"http://xyom.github.io/tags/Node-js/"}]},{"title":"Multer를 이용한 파일 올리기","slug":"Multer를 이용한 파일 올리기","date":"2017-12-08T08:47:39.882Z","updated":"2017-12-08T08:47:39.882Z","comments":true,"path":"2017/12/08/Multer를 이용한 파일 올리기/","link":"","permalink":"http://xyom.github.io/2017/12/08/Multer를 이용한 파일 올리기/","excerpt":"","text":"Multer를 이용한 파일 올리기프로젝트 모듈에 multer를 추가한다. 1npm install --save multer Node의 해당 프로젝트로 이동하여 위의 명령어를 입력하고 multer 모듈을 설치한다. 2. 서버의 요청에 사용할 Api를 만든다.12345678910111213141516171819202122232425var express = require(&apos;express&apos;);var multer = require(&apos;multer&apos;);var router = express.Router();var path = require(&apos;path&apos;);const upload = multer(&#123;storage : multer.diskStorage(&#123; destination: function(req,file,cb) &#123; cb(null,&apos;../../static/images/&apos;); &#125;, filename: function(req,file,cb) &#123; cb(null,new Date().valueOf() + path.extname(file.originalname)); &#125;&#125;),&#125;);router.post(&apos;/up&apos;,upload.single(&apos;img&apos;),function(req,res,err)&#123; var originalPath = &apos;yourUrl/images/&apos;; var filename = originalPath + req.file.filename; res.status(200).json(&#123; result : &apos;success&apos;, path : filename &#125;);&#125;); 서버로 요청할 api를 만들어 받은 요청에 대해 multer를 이용하여 이미지를 저장하고 저장된 경로를 반환 해주도록 한다. 라우터에 post 방식으로 up이라는 요청이 들어왔을 경우 upload.single()에 의해 하나의 파일만 받아 저장하게 된다. 여러개를 저장할 경우 upload.array()를 통해 받을 수 있다, 또한 필드명 별로 여러개의 사진을 받을 경우 .fields 메서드를 이용한다. cont upload에는 multer가 저장할 저장 위치를 정해준다. 위에서 multer가 저장할 저장 위치와 파일명에 대해서 명시적으로 지정해주는 것은 multer에 의해 확장자가 자동으로 제거된 이름으로 명명되는 것을 임의로 설정해 주는 것이다. 1const upload = multer(&#123;dest : &apos;images&apos;&#125;); 만약 multer의 파라미터에 간단하게 dest만 넣어주게 되면 multer를 통해 저장된 파일의 이름이 0ax5e4f725… 과같은 문자로 바뀌어 반환되게 된다. 또한 확장자 까지 제거된 상태로 파일이 저장되므로 static 서버에 저장한뒤 단순히 자원의 이름으로만 접근하게 되면 이미지 파일이 바로 보이지 않고 확장자 없는 파일이 다운된다. 3. Client에서의 요청123456789101112131415161718192021$.ajax(&#123; url : uploadURL, type : &quot;POST&quot;, contentType : false, processData : false, cache : false, data : formData, success: function(data) &#123; status.setUrlName(data.path); console.log(data); &#125;, error:function(request, status, error) &#123; console.log(error); &#125; &#125; ); Client에서의 요청은 위와 같이 ajax를 이용해 요청 하였다. 서버에서의 방식과 마찬가지로 POST로 맞춰주고 data: 항목에는 전송할 데이터 파일의 form형 데이터를 넣는다. 12var formData = new FormData();fd.append(&apos;img&apos;, 파일 객체); formData는 위와 같이 formData에 필드명과 함께 파일객체를 넣어주어 ajax로 요청하게 된다. 이와 같은 작업을 같은 도메인 내에서 한다면 문제가 발생하지 않지만 원격으로 떨어진 서버로 요청을 보내게 될 경우 Same-Origin Policy 문제가 발생한다. Cross-Domain 문제는 ajax의 요청을 같은 도메인이 아닌 다른 도메인을 가진 서버로 요청을 보내는 경우에 제약이 걸리는 것이다. (보안적인 문제를 위해 막았다고 한다.) 위 문제에 대해 Jsonp를 이용해 해결할 수 있는데 Jsonp는 script 요소로 요청되는 호출이 보안 정책에 적용되지 않는점을 이용한 것이라고 한다. 서버측에서 해결하는 방법으로는 서버측에서 Cross Domain을 허용해 주면 된다. -&gt; Node js에서는 cors 모듈을 통해 아주 간단하게 해결 할 수 있다. 1npm install --save cors 모듈을 설치하고 123456var cors = require(&apos;cors&apos;);...app.use(cors()); 를 해주면 문제가 해결된다. 웹 쪽 클라이언트를 많이 다루어 보지 않았지만 웹에서는 이러한 문제가 발생할 수 있다는 것을 알고 넘어가도록 해야겠다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://xyom.github.io/categories/Programming/"},{"name":"Node js","slug":"Programming/Node-js","permalink":"http://xyom.github.io/categories/Programming/Node-js/"}],"tags":[{"name":"Node js","slug":"Node-js","permalink":"http://xyom.github.io/tags/Node-js/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-12-08T08:23:44.171Z","updated":"2017-12-08T08:23:44.171Z","comments":true,"path":"2017/12/08/hello-world/","link":"","permalink":"http://xyom.github.io/2017/12/08/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}