<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Gunner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="My Tech Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Gunner">
<meta property="og:url" content="http://xyom.github.io/page/3/index.html">
<meta property="og:site_name" content="Gunner">
<meta property="og:description" content="My Tech Blog">
<meta property="og:locale" content="ko">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Gunner">
<meta name="twitter:description" content="My Tech Blog">
  
    <link rel="alternate" href="/atom.xml" title="Gunner" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Gunner</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Gunner</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="검색"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://xyom.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-스케줄링" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/01/스케줄링/" class="article-date">
  <time datetime="2018-01-01T11:10:28.591Z" itemprop="datePublished">2018-01-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CS/">CS</a>►<a class="article-category-link" href="/categories/CS/운영체제/">운영체제</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/01/스케줄링/">CPU 스케줄링</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="스케줄링"><a href="#스케줄링" class="headerlink" title="스케줄링"></a>스케줄링</h2><p> 스케줄링이랑 CPU에서 어떠한 프로세스가 실행되어야 할지 결정하는 작업이다. 적절한 스케줄링을 해야만 컴퓨터 작업의 효율성이 향상되고 반환시간이 단축된다.</p>
<p> 스케줄링을 하는데 고려해야 할 요소는 CPU 이용률 , 처리량, 반환시간,대기 시간, 응답시간이 있다. 스케줄링은 수행되고 있는 프로세스를 뺏을 수 있냐 없냐에 따라서 선점/비선점 스케줄링으로 구분된다.</p>
<h2 id="비선점-스케줄링"><a href="#비선점-스케줄링" class="headerlink" title="비선점 스케줄링"></a>비선점 스케줄링</h2><p> 비선점 스케줄링이란 현재 실행되고 있는 프로세스의 작업을 중단시키고 CPU의 이용을 빼앗을 수 없는 스케줄링이다. 대표적으로 FCFS, SJF, HRN, 우선순위 방식이 있다.</p>
<h4 id="FCFS-First-Come-First-Served"><a href="#FCFS-First-Come-First-Served" class="headerlink" title="FCFS (First Come First Served)"></a>FCFS (First Come First Served)</h4><p><img src="https://www.tutorialspoint.com/operating_system/images/fcfs.jpg" alt=""></p>
<p> 도착한 순서대로 스케줄링하는 가장 간단한 스케줄링 방식이다. 구현이 매우 쉽지만 우선순위가 높아 먼저 처리해야 하는 프로세스가 생겨도 먼저 처리할 수 없는 단점을 가지고 있다. 위의 그림에서 P0,P1,P2,P3순으로 도착 했으므로 순서대로 할당한다.</p>
<h4 id="SJF-Shortest-Job-First"><a href="#SJF-Shortest-Job-First" class="headerlink" title="SJF(Shortest Job First)"></a>SJF(Shortest Job First)</h4><p><img src="https://www.tutorialspoint.com/operating_system/images/sjf.jpg" alt=""></p>
<p>  SJF는 가장 짧은 서비스 시간을 갖는 프로세스를 가장 먼저 실행하는 스케줄링이다. 위 그림에서는 서비스 시간이 가장 짧은 순서대로 p1, p0 ,p3,p2 순으로 실행되며 모든 스케줄링 중에서 평균 반환시간이 가장 짧은 스케줄링이다. 하지만 짧은 수행시간을 가지는 작업이 계속 들어올 경우 상대적으로 긴 작업이 계속 뒤로 밀려나는 기아 현상이 발생할 수 있다.</p>
<h4 id="HRN-Highest-Response-Ratio-Next"><a href="#HRN-Highest-Response-Ratio-Next" class="headerlink" title="HRN(Highest Response Ratio Next)"></a>HRN(Highest Response Ratio Next)</h4><p><img src="https://kldp.org/files/aaa_6.jpg" alt=""></p>
<p> HRN은 SJF의 기아문제를 해결하기 위한 스케줄링 방법으로 (서비스 시간 + 대기시간) / 서비스 시간으로 나눈 값을 우선순위로 결정하여 이 값이 작은 프로세스를 우선적으로 수행한다. </p>
<h4 id="우선순위-비선점"><a href="#우선순위-비선점" class="headerlink" title="우선순위 ( 비선점)"></a>우선순위 ( 비선점)</h4><p> 프로세스의 우선순위를 기준으로 우선순위가 높은 프로세스 순으로 스케줄링하는 기법이다. 비선점이기 때문에 높은 우선순위의 프로세스가 들어와도 현재 실행하는 프로세스는 계속 실행한다.  </p>
<h2 id="선점-스케줄링"><a href="#선점-스케줄링" class="headerlink" title="선점 스케줄링"></a>선점 스케줄링</h2><p> 선점 스케줄링은 CPU의 이용을 빼앗을 수 있는 스케줄링 기법이다. 비선점과 다르게 수행되고 있는 현재 프로세스를 중단시키고 다른 프로세스를 먼저 실행할 수 있다.</p>
<h4 id="RR-Roudn-Robin"><a href="#RR-Roudn-Robin" class="headerlink" title="RR(Roudn Robin)"></a>RR(Roudn Robin)</h4><p><img src="http://www.myassignmenthelp.net/images/round-robin-example.gif" alt=""></p>
<p>라운들 로빈 방식은 시분할 방식으로 프로세스를 time slice만큼만 실행하도록 하는 방식이다. 위에서의 time slice 간격은 4로 4만큼 수행한뒤 다른 프로세스에게 cpu 이용을 넘겨주게 된다. 이 방식을 통하여 사용자는 프로세스 여러개가 동시에 수행되는 것 처럼 느낄 수 있다.</p>
<h4 id="SRT-Shortest-Remaining-First"><a href="#SRT-Shortest-Remaining-First" class="headerlink" title="SRT(Shortest Remaining First)"></a>SRT(Shortest Remaining First)</h4><p> SJF의 선점형 방식으로 SJF와 다른점은 더 짧은 작업이 들어왔을 경우 CPU를 빼앗을 수 있다는 점이다.</p>
<h4 id="Multilevel-Queue-다단계-큐"><a href="#Multilevel-Queue-다단계-큐" class="headerlink" title="Multilevel Queue(다단계 큐)"></a>Multilevel Queue(다단계 큐)</h4><p><img src="http://elgoacademy.org/wp-content/uploads/2017/03/6_06_MultilevelQueueScheduling.jpg" alt=""></p>
<p> 다단계 큐는 cpu의 ready 큐를 우선순위에 따라 여러개로 나눈 것이다. 각 큐는 독립적인 스케줄링 알고리즘을 가지고 각 큐에 대해 Cpu time을 적절히 할당하여 수행한다.  대표적으로 Foreground /Background 큐가 있는데 Foreground 큐는 RR 방식, Background 큐는 FCFS 방식 으로 스케줄링하며 80: 20의 CPU 이용시간을 가지고 작업을 처리하도록 구현한다.</p>
<h4 id="Multilevel-Feedback-Queue"><a href="#Multilevel-Feedback-Queue" class="headerlink" title="Multilevel Feedback Queue"></a>Multilevel Feedback Queue</h4><p><img src="https://worldfullofquestions.files.wordpress.com/2014/07/multilevel-feedback-queue-scheduling.png?w=665" alt=""></p>
<p> 다단계 피드백큐는 다단계 큐가 서로 다른 큐로 이동할 수 있는 큐의 구조이다. 위의 그림에서 quantum 즉 timeslice가 8/16인 큐와 fsfs인 큐가 존재한다. 프로세스는 처음 첫번째 큐에서 8의 큐를 할당받고 프로세스를 수행한다. 만약 다 완료하지 못하면 16인 큐로 이동하고 이마저도 완료하지 못하면 fcfs로 이동하여 순차적으로 처리하게 된다. -&gt; 이는 aging 기법을 이용한 것으로 프로세스가 시간이 지날수록 더 많은 수행시간을 가지게 함으로써 작업을 마칠 수 있도록 한다.</p>
<h2 id="실시간-스케줄링"><a href="#실시간-스케줄링" class="headerlink" title="실시간 스케줄링"></a>실시간 스케줄링</h2><p> 실시간 스케줄링은 작업이 마감시한 내에 완료되도록 스케줄링하는 것이다.  이 스케줄링을 적용하는 시스템은 다음과 같은 시스템들이 있다.</p>
<ul>
<li>경성 실시간 시스템 -  작업이 마감시간내에 완료되지 않으면 치명적인 시스템</li>
<li>연성 실시간 시스템 -  작업이 마감시간내에 완료되지 않아도 되지만 시간이 지날수록 손해가 점점 커지는 시스템</li>
</ul>
<h4 id="RM-Rate-Monotonic-알고리즘"><a href="#RM-Rate-Monotonic-알고리즘" class="headerlink" title="RM(Rate Monotonic) 알고리즘"></a>RM(Rate Monotonic) 알고리즘</h4><p> 작업의 크기와 개수가 알려진 프로세스들이 주기적으로 발생하는 환경에서 사용한다. 프로세스는 각자 독립적이고 주기적으로 수행되는 환경에서 각 프로세스의 마감시한은 각자의 주기와 같다고 가정하고 주기가 짧을수록 높은 우선순위를 받게 된다. -&gt; 주기가 짧을수록 프로세스가 다시 발생하므로 빨리 수행해야 한다. RM은 선점 스케줄링 방식으로 높은 우선순위 작업에게 CPU를 뺴앗길 수 있다.</p>
<h4 id="EDF-Earlist-Deadline-First-알고리즘"><a href="#EDF-Earlist-Deadline-First-알고리즘" class="headerlink" title="EDF(Earlist Deadline First) 알고리즘"></a>EDF(Earlist Deadline First) 알고리즘</h4><p> EDF 알고리즘은 프로세스의 마감시한이 가까워질수록 우선순위를 높게 부여하는 선점 방식의 동적 스케줄링이다. EDF 기법은 우선순위에 의해 CPU를 뺏길 수 있다. 한 프로세스의 실행이 완료되면 마감시간이 가장 가까운 것을 찾아 스케줄링 한다. 모든 프로세스가 주기적일 필요가 없으며 주기가 있을 경우 마감시간을 주기로, 그렇지 않을 경우 마감시간을 명시적으로 알려주어야 한다. </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xyom.github.io/2018/01/01/스케줄링/" data-id="cjdj0kc3a004hltqr8x3u0y5f" class="article-share-link">공유</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CPU-스케줄링/">CPU 스케줄링</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-프로세스 동기화" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/01/프로세스 동기화/" class="article-date">
  <time datetime="2018-01-01T11:10:28.579Z" itemprop="datePublished">2018-01-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CS/">CS</a>►<a class="article-category-link" href="/categories/CS/운영체제/">운영체제</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/01/프로세스 동기화/">프로세스/스레드 동기화</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="프로세스-동기화"><a href="#프로세스-동기화" class="headerlink" title="프로세스 동기화"></a>프로세스 동기화</h2><p> 동기화란 병렬적으로 수행되는 작업들에 대해 자원에의 접근에 대한 순서를 정하는 과정을 말한다. 여러개의 프로세스나 쓰레드의 경우 동시에 특정 자원에 대한 접근이 발생할 수 있는데 이 과정에서 자원에 대해 동시 접근을 허용해 버린다면 예기치 못한 결과를 발생시킬 수 있다.</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  x = a+<span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> Thread A와 Thread B가 전역변수 x에 대해 cal(x)를 동시에 수행했다고 가정해보자 사용자는 cal(x)를 두번 호출해서 12의 결과를 얻기를 원했다 하지만 Thread의 수행 순서는 예측할수 없기 때문에 Thread A와 Thread B가 모두 cal(x)를 호출하여 전역 변수 x의 을 자신의 local 변수 a에 복사하였다. 이 경우 Thread A와 Thread B는 10에 대하여 +1한값을 x에 집어넣기 때문에 x에는 최종적으로 11의 값이 들어가게 된다.</p>
<p> -&gt; 두 쓰레드의 실행 순서가 보장되지 않았기 때문에 예상한 결과와 다른 결과를 나타내었다.</p>
<p> 이렇게 예상치 못한 결과에 대하여 방지하고 한정된 자원에 대해 접근 순서를 보장하는 것을 동기화라고 한다.</p>
<h2 id="임계구역"><a href="#임계구역" class="headerlink" title="임계구역"></a>임계구역</h2><p> 임계 구역 (Critical Section)이란 동시에 접근하는 것을 제한해야 하는 구역이다.  즉 쓰레드나 프로세스에 의해 한번에 한 프로세스 or 스레드가 접근하기를 원하는 구역이다. Mutex의 경우 락을 걸고 락을 푸는 사이의 영역이 임계구역이 된다. 임계구역은 자원에 대한 접근이나 연산이 동시에 이루어지지 않아야 하는 구역에 대하여 설정한다.</p>
<p>##Mutex vs SemaPhore</p>
<p> 뮤텍스와 세마포어는 동기화를 위한 도구이다. 뮤텍스와 세마포어는 흔히들 말하는 화장실에 들어가는 키라고 말할 수 있다. 화장실에는 한번에 한명밖에 들어갈 수 없기 때문에 키를 획득한 사람만 들어갈 수가 있다. </p>
<p>뮤텍스와 세마포어의 차이라 함은 이 키에 대한 개수에서 차이가 있다. Mutex는 키가 1개이기 때문에 화장실에 한번에 한명 들어갈 수 있지만 세마포어는 키가 여러개여서 여러명이 들어갈 수 있다.</p>
<p> 뮤텍스와 세마포어를 구현하는 방식은 Busy - wait를 통해 키를 획득할때 까지 빈 while문을 실행하는 방법과 프로세스의 상태를 sleep으로 전환시킨 뒤 실행해야 할 때 wake up 시켜 ready queue에 집어넣는 방법이 있다.</p>
<h5 id="Busy-waiting"><a href="#Busy-waiting" class="headerlink" title="Busy - waiting"></a>Busy - waiting</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> key = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(key &lt; <span class="number">0</span>)&#123;&#125;</span><br><span class="line">  key--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    key = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  lock();</span><br><span class="line">  x = a+<span class="number">1</span>;</span><br><span class="line">  unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Busy -waiting은 key를 획득하지 못하면 while문을 계속해서 돌게 된다. 위의 코드에서는 key의 값이 0일때 임계영역에 들어갈 수 있다. 하지만 쓰레드는 순서에 대한 보장이 없으므로 key 값을 읽었을 때 동시에 여러 스레드가 0값을 읽을 가능성이 있다. 이에 대한 해결방법은 하드웨어적인 방법을 이용한 test - and - set 명령어를 사용하는 것이다. test and set은 변수를 읽는 중에 다른 쓰레드가 덮어 썼는지 확인하고 다시 읽기 때문에 이 문제를 해결할 수 있으며 많은 뮤텍스 세마포어가 test and set을 이용하여 구현한다.</p>
<h5 id="Sleep-wake-up"><a href="#Sleep-wake-up" class="headerlink" title="Sleep - wake up"></a>Sleep - wake up</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> value;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">L</span>;</span></span><br><span class="line">&#125;semaphore;</span><br></pre></td></tr></table></figure>
<p><img src="http://52.79.231.100:4000/images/1514803017958.PNG" alt=""></p>
<p>Sleep - wake up 방식은 위의 방식에서 while문 대신 해당 프로세스를 sleep 시킨뒤 sleep 대기 큐에 집어넣고 완료하면 꺼내는 방식을 이용해 구현한다.</p>
<p>Busy-wait 방식과 Sleep wait 방식의 효율성을 비교하면 평균적으로 Sleep wait 방식이 더욱 좋다. Busy- wait의 경우 기다리는 동안 while문으로 회전하기 때문에 cpu의 쓸데 없는 사용이 생겨나게 된다. 하지만 Sleep wait 방식의 경우 프로세스의 상태를 변경시키고 ready queue에 넣기 때문에 wait queue에서 ready queue로 비용이 든다.  따라서 cpu 사용량이 짧을경우 busy-wait 방식이 더욱 빠르다고 한다.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xyom.github.io/2018/01/01/프로세스 동기화/" data-id="cjdj0kc3n004ultqr8klyg5cl" class="article-share-link">공유</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/프로세스-쓰레드-동기화/">프로세스/ 쓰레드 동기화</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Rest API" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/31/Rest API/" class="article-date">
  <time datetime="2017-12-31T09:16:30.420Z" itemprop="datePublished">2017-12-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CS/">CS</a>►<a class="article-category-link" href="/categories/CS/ETC/">ETC</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/31/Rest API/">Rest API란</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> REST(<strong>RE</strong>presentational <strong>S</strong>tate <strong>T</strong>ransfer)란 HTTP 통신에 있어서 자원에 대한 조회, 변경, 삽입, 삭제 요청을 자원(Uri)과 행위(Method)로 표현하여 설계하는 방식을 말한다.</p>
<p> REST에는 대표적으로 GET,POST ,PUT, DELETE METHOD가 있으며 자원에 대해 이 METHOD 방법에 따라 서버에서 수행하는 동작이 달라지도록 설계한다.</p>
<p>  예를들어 <a href="http://서버:8080/member/1024를" target="_blank" rel="noopener">http://서버:8080/member/1024를</a> GET 방식으로 호출한다는 것은 회원번호가 1024번인 멤버의 정보를 조회하겠다는 것을 의미한다.  똑같은 방식으로 이를 DELETE 방식으로 호출하게 되면 1024인 멤버의 정보를 삭제하겠다는 것을 의미하고 PUT 방식으로 호출하면 Body의 내용에 보낸 정보를 바탕으로 1024인 멤버의 정보를 수정하겠다는 것을 의미한다. 이렇게 자원에 대해서는 Uri로 표현하고 이에 대한 행동을 Method로 표현하면 표현의 의미가 분명해지고 Rest api 규칙을 지켜서 설계된 api에 대하여 Restful 한 api라고 말한다.</p>
<h5 id="설계의-규칙"><a href="#설계의-규칙" class="headerlink" title="설계의 규칙"></a>설계의 규칙</h5><ul>
<li><p>리소스와 행위를 명시적이고 직관적으로 분리한다.</p>
<ul>
<li><a href="http://서버:8080/delete/member와" target="_blank" rel="noopener">http://서버:8080/delete/member와</a> 같이 uri안에  행위를 포함하는 표현이 있어서는 안된다.</li>
<li>행위는 GET(조회),POST(삽입),PATCH(일부 수정),PUT(객체 전체 수정),DELETE(삭제),HEAD(Body없이 헤더만 받음), OPTIONS(해당 리소스에 가능한 operation을 응답) 등으로 표현한다.</li>
</ul>
<p>​</p>
</li>
<li><p>Message는 Header와 Body를 명확하게 구분하여 분리해 사용한다.</p>
<ul>
<li><p>Entity에 대한 내용은 Body에 담아 전송한다. -&gt; 수정하거나 삽입하려는 정보에 대한 내용은 Body에 담아 전송한다.</p>
</li>
<li><p>API 버전 정보,MIME 타입 등은 header에 담는다.</p>
<p>​</p>
</li>
</ul>
</li>
</ul>
<h4 id="장점"><a href="#장점" class="headerlink" title="장점"></a>장점</h4><p>  REST API의 장점이라고 하면 API의 요청 방식 자체로 API가 어떤식으로 동작하는지 명확하게 알 수 있고 인가된 요청자들에 대해 언제 어디서나 데이터를 제공할 수 있다. -&gt; Open Api를 제공하기가 쉽다.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xyom.github.io/2017/12/31/Rest API/" data-id="cjdj0kc02000oltqrboxzzyyq" class="article-share-link">공유</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Rest-API/">Rest API</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-객체지향 프로그래밍이란" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/31/객체지향 프로그래밍이란/" class="article-date">
  <time datetime="2017-12-31T09:16:30.404Z" itemprop="datePublished">2017-12-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CS/">CS</a>►<a class="article-category-link" href="/categories/CS/JAVA/">JAVA</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/31/객체지향 프로그래밍이란/">객체 지향 프로그래밍</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>  객체 지향 프로그래밍이란 실세계에서의 개념을  추상화하여 프로그래밍 상의 객체로 옮겨 놓는 방식으로 코드를 작성하는 방법을 말한다. 예를 들면 자동차라는 객체를 프로그래밍 하려면 자동차의 특성과 기능을 추려 이를 프로그래밍 할 수 있다. 자동차는 바퀴,헤드라이트, 핸들, … 등을 가지고 전진, 후진, 방향 전환 등의 기능을 가지고 있다. 이러한 특성과 기능을 모아 자동차라는 객체 클래스를 만들면 추가적인 특성을 가진 자동차 객체를 코딩하거나 자동차 객체를 여러개 생성하게 될 때 등등 코드를 재사용률이 커진다.</p>
<p>  객체 지향 프로그래밍에는 4가지 특성과 5가지의 설계원칙이 있다.</p>
<h3 id="객체지향-4가지-특성"><a href="#객체지향-4가지-특성" class="headerlink" title="객체지향 4가지 특성"></a>객체지향 4가지 특성</h3><ul>
<li><p>추상화 - 추상화란 현실 세계의 객체의 공통된 특징과 기능을 추출하는 것을 의미한다. 동물은 사자, 원숭이, 코끼리 등등 많은 것이 존재하지만 이 동물들의 기본적인 특성과 기능을 모아 동물이라는 클래스를 정의하는 것을 추상화라고 한다. 동물은 모두 호흡을하고 심장을가지고 있으며 움직인다라는 특성과 기능을 가지고 있는데 이러한 것들을 한군데 모아 정의하는 것을 의미한다.</p>
<p>​</p>
</li>
<li><p>다형성 - 다형성에는 오버로딩과 오버라이딩이 있다. 똑같은 이름의 함수여도 함수의 인자의 갯수나 타입, 상속 받은 객체에서의 오버라이딩에 대해서 다르게 동작하는 것을 의미한다.</p>
<ul>
<li><p>오버로딩은 파라미터의 개수나 타입이 다른 함수를 정의하는 것을 의미한다. 예를 들어 두 정수를 더하는 public void sum(int a,int b)라는 함수를 정의했다고 하면 두 실수를 더하기 위한 함수인 public void sum(double a,double b)함수를 정의할 수 있다. 이 함수는 똑같은 이름으로 호출하지만 집어넣는 인자의 타입에 따라 다른방식으로 동작할 수 있다.</p>
</li>
<li><p>오버라이딩은 상속에 의해 부모가 가진 함수를 재정의 하여 사용하는 것을 의미한다. 부모 객체가 ‘안녕 나는 부모’라는 메시지를 출력하는 say()라는 함수를 가지고 있다고 하면 자식 객체는 부모 객체를 상속받으면서 이 함수에 대해 오버라이딩을 하여 ‘안녕 나는 자식’이라는 메시지를 출력하도록 변경할 수 있다. </p>
<p>​</p>
</li>
</ul>
</li>
<li><p>상속성 - 상속성은 부모 객체의 특성을 자식이 물려받는 것을 의미한다. 상속을 통해 부모가 가진 기능에 대하여 물려받아 사용할 수 있다. 예를 들어 자동차라는 클래스를 상속받은 슈퍼카 클래스는 기본 기능인 전진, 후진, 방향 전환 등의 기능을 모두 물려받고 자신의 특성인 부스트, 드리프트 기능등 자신의 특징만 추가하면된다.</p>
<p>​</p>
</li>
<li><p>캡슐화 - 캡슐화란 클래스가 동작하는 것에 대해 사용자가 그 내부 동작을 모르게 동작한다는 것을 의미한다. 예를 들어 환자는 감기약이라는 캡슐 알약 하나를 먹지만 캡슐 알약에는 항생제, 수면제, 등등 많은 작용을 하는 성분들이 들어가 있고 작용을 하지만 환자는 이를 알 수 없다. 이처럼 클래스는 자신이 동작하는 것에 대해 사용자가 알 필요가 없이 동작하는 것을 캡슐화라고 한다.</p>
</li>
</ul>
<h3 id="객체지향-5가지-설계-원칙"><a href="#객체지향-5가지-설계-원칙" class="headerlink" title="객체지향 5가지 설계 원칙"></a>객체지향 5가지 설계 원칙</h3><ul>
<li>SRP(Single Responsibility Principle) 단일 책임 원칙<ul>
<li>클래스는 단 하나의 기능을 가지고 클래스가 제공하는 모든 서비스는 그 하나의 기능을 수행하는 데 집중해 있어야 한다. </li>
</ul>
</li>
<li>OCP(Open - Closed Principle) 개방 폐쇄의 원칙<ul>
<li>확장에는 열려있고 변경에는 닫혀있어야 한다.</li>
</ul>
</li>
<li>LSP(Liskov Substitution Principle) 리스코프 치환 원칙<ul>
<li>상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.</li>
</ul>
</li>
<li>ISP(Interface Segregation Principle) 인터페이스 분리 원칙<ul>
<li>인터페이스는 그 인터페이스를 사용하는 사용자 기준으로 분리해야 한다.</li>
</ul>
</li>
<li>DIP(Dependency Inversion Principle) 의존 역전의 법칙 <ul>
<li>고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.</li>
</ul>
</li>
</ul>
<p><a href="http://www.nextree.co.kr/p6960/" target="_blank" rel="noopener">5가지 설계 원칙 참고</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xyom.github.io/2017/12/31/객체지향 프로그래밍이란/" data-id="cjdj0kc09000yltqrtyluww4g" class="article-share-link">공유</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/객체-지향-프로그래밍-JAVA/">객체 지향 프로그래밍 / JAVA</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-선택 정렬" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/28/선택 정렬/" class="article-date">
  <time datetime="2017-12-28T10:51:33.284Z" itemprop="datePublished">2017-12-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Programming/">Programming</a>►<a class="article-category-link" href="/categories/Programming/Algorithm/">Algorithm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/28/선택 정렬/">선택 정렬</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://i.stack.imgur.com/1SKb2.jpg" alt=""></p>
<p>  선택정렬은 데이터의 원소중에 가장 작은 최솟값의 인덱스를 찾은뒤 이를 교환해 주는 방법으로 동작한다.  위의 첫번째 단계를 보면 1이라는 최소 원소를 찾은 뒤 가장 이를 8의 원소의 위치와 교환해 주어 가장 최소의 값을 앞에 위치 시키는 것으로 볼 수 있다. 그 다음 최소값을 찾으면 3을 찾았고 그 다음 최솟값이 위치해야 할 5의 위치와 원소를 바꾸어주었다. 이와 같은 과정을 n-1번 반복하면서 최솟값을 찾는데 약 n의 시간이 소요되므로 O(n2)의 시간복잡도를 가진 정렬이다.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = arr[a];</span><br><span class="line">	arr[a] = arr[b];</span><br><span class="line">	arr[b] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m_index;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.size() - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		m_index = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; arr.size(); j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &lt; arr[m_index])</span><br><span class="line">				m_index = j;</span><br><span class="line">		&#125;</span><br><span class="line">		swap(arr, i, m_index);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">		arr.push_back(rand() % <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">	selectionSort(arr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>, arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xyom.github.io/2017/12/28/선택 정렬/" data-id="cjdj0kc340048ltqrdkozwv8h" class="article-share-link">공유</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/선택-정렬/">선택 정렬</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-버블 정렬" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/28/버블 정렬/" class="article-date">
  <time datetime="2017-12-28T10:51:33.256Z" itemprop="datePublished">2017-12-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Programming/">Programming</a>►<a class="article-category-link" href="/categories/Programming/Algorithm/">Algorithm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/28/버블 정렬/">버블 정렬</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://image.slidesharecdn.com/shanawar-160907015739/95/bubble-sorting-of-an-array-in-8086-assembly-language-5-638.jpg?cb=1473213645" alt=""></p>
<p> 버블 정렬은 가장 큰 원소를 바깥쪽으로 밀어내는 방식으로 정렬하는 방식이다. 처음 원소부터 자신의 다음 원소와 비교하여 더 큰 숫자를 비교하며 더 큰 숫자를 교환하여 뒤로 밀어내는 방식으로 정렬을 한다.</p>
<p> 위의 그림을 보면 첫번째 원소 9와 6을 보고 9가 더 크므로 9를 뒤로 밀어내고 그 다음으로 넘어가 9와 2를 비교해 9가 더크니 위치를 다시 바꾼다. 이와 같은 과정을 반복해 나가면 가장 큰 숫자가 가장 뒤로 위치하게 되고 다음번에 수행할 때는 그 다음 큰 숫자가 오게 되므로 마지막 전에 위치 시킨다.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size - i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> temp = arr[j];</span><br><span class="line">				arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">				arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">		arr[i] = rand()%<span class="number">1000</span>;</span><br><span class="line">	BubbleSort(arr, <span class="number">10</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>, arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xyom.github.io/2017/12/28/버블 정렬/" data-id="cjdj0kc330045ltqrrqzbnfq4" class="article-share-link">공유</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/버블-정렬/">버블 정렬</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-삽입 정렬" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/28/삽입 정렬/" class="article-date">
  <time datetime="2017-12-28T10:51:33.256Z" itemprop="datePublished">2017-12-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Programming/">Programming</a>►<a class="article-category-link" href="/categories/Programming/Algorithm/">Algorithm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/28/삽입 정렬/">삽입 정렬</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://www.ee.ryerson.ca/~courses/coe428/files/4_a.gif" alt=""></p>
<p> 삽입 정렬은 정렬된 상태의 영역을 확대해 나가면서 그 다음의 후보가 삽입될 위치를 찾아 삽입한 뒤 그 다음 원소들을 밀어내는 방식으로 동작한다.</p>
<p> 처음의 영역의 크기는 1로 가장 첫번째 원소만 포함한다. 위의 그림을 보면 5라는 원소가 크기 1인 영역에 속해 있고 2라는 다음 원소를 이 영역에 집어 넣는데 이 영역의 원소들과 비교해서 더 큰 숫자를 만나면 그 숫자의 전에 집어넣고 그  뒤로는 밀어낸다. 결과 2가 5의 앞으로 오고 5가 밀려나 2의 자리를 차지한다. 이와 같은 과정을 반복하게 되면 모든 원소들이 삽입되고 정렬된 결과를 얻게된다.</p>
<p> 버블 정렬과 마찬가지로 O(n2)의 시간복잡도를 갖는다.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = arr[a];</span><br><span class="line">	arr[a] = arr[b];</span><br><span class="line">	arr[b] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.size(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[i] &lt; arr[j])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> temp = arr[i];</span><br><span class="line">				<span class="built_in">memcpy</span>(&amp;arr[j+<span class="number">1</span>], &amp;arr[j], <span class="keyword">sizeof</span>(<span class="keyword">int</span>*) *(i - j));</span><br><span class="line">				arr[j] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">		arr.push_back(rand() % <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">	InsertSort(arr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>, arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xyom.github.io/2017/12/28/삽입 정렬/" data-id="cjdj0kc310042ltqrzk7ws5qs" class="article-share-link">공유</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/삽입-정렬/">삽입 정렬</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-병합 정렬" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/28/병합 정렬/" class="article-date">
  <time datetime="2017-12-28T10:51:33.232Z" itemprop="datePublished">2017-12-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Programming/">Programming</a>►<a class="article-category-link" href="/categories/Programming/Algorithm/">Algorithm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/28/병합 정렬/">병합 정렬</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="http://www.studytonight.com/data-structures/images/merge-sort-1.png" alt=""></p>
<p>  병합정렬은 퀵정렬과 대표되는 O(nlogn)의 시간복잡도를 가진 정렬로 최악에 O(n2)의 시간복잡도를 가지는 퀵정렬과 달리 모든 경우의 O(nlogn)의 시간복잡도를 가지는 정렬이다. 또한 퀵정렬이 분할해 나가면서 정렬하는 방식이었다면 병합정렬은 모두 분할한 뒤 그 결과를 합치는 방법으로 약간의 차이가 있다. 병합정렬의 단점은 병합된 결과를 저장하기 위한 배열이 필요하기 때문에 메모리를 많이 차지할 수 있다.</p>
<p> 병합정렬을 하는 과정은 배열을 mid를 기준으로 크기가 1인 배열이 될 때 까지 나누게 된다. 왼쪽 오른쪽으로 나눈 결과는 정렬 과정을 거치며 합쳐지고 이 과정을 반복하여 정렬을 수행해 나간다.</p>
<p> 나뉘어진 원소를 합치면서 정렬하는 과정은 두 배열의 원소의 크기를 비교해나가며 작은 순서로 정렬된 결과 배열에 집어 넣는 것이다. {2,5} {4,6} 이라는 배열이 존재하면 각각 비교할 서로의 인덱스를 선언한다. 그리고 그 인덱스에 해당하는 아이템을 비교하고 더 작으면 결과 배열에 넣고 더 작았던 쪽 배열의 인덱스를 증가시킨다.</p>
<p> 이 과정을 반복하고 마지막에 남은 원소들을 모두 끝에 넣어주게 되면 정렬된 결과가 나오게 된다. 이 과정이 반복되면서 정렬된 왼쪽, 오른쪽 배열들이 다시 합쳐지면서 정렬되어 최종으로 모두 정렬된 결과가 나오게 된다.</p>
<p>아래의 코드에서 MergeSort1은 결과를 저장하기 위해 배열을 선언한 것이고 MergeSort2는 배열 내에서 정렬을 수행한 코드이다. </p>
<h4 id="MergeSort1"><a href="#MergeSort1" class="headerlink" title="MergeSort1"></a>MergeSort1</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Merge(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr2)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">	<span class="keyword">int</span> arr1_index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> arr2_index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (arr1_index &lt; arr1.size() &amp;&amp; arr2_index &lt; arr2.size())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (arr1[arr1_index] &lt; arr2[arr2_index])</span><br><span class="line">		&#123;</span><br><span class="line">			result.push_back(arr1[arr1_index]);</span><br><span class="line">			arr1_index++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			result.push_back(arr2[arr2_index]);</span><br><span class="line">			arr2_index++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (arr1_index &lt; arr1.size())</span><br><span class="line">	&#123;</span><br><span class="line">		result.push_back(arr1[arr1_index]);</span><br><span class="line">		arr1_index++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (arr2_index &lt; arr2.size())</span><br><span class="line">	&#123;</span><br><span class="line">		result.push_back(arr2[arr2_index]);</span><br><span class="line">		arr2_index++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; MergeSort(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (left &lt; right)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr1 = MergeSort(arr, left, mid);</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr2 = MergeSort(arr, mid + <span class="number">1</span>, right);</span><br><span class="line">		<span class="keyword">return</span> Merge(arr1, arr2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">		temp.push_back(arr[left]);</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">		arr.push_back(rand() % <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result = MergeSort(arr, <span class="number">0</span>, arr.size() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>, result[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​                            정렬된 결과를 따로 리턴하는 병합 정렬 </p>
<h4 id="MergeSort2"><a href="#MergeSort2" class="headerlink" title="MergeSort2"></a>MergeSort2</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">	<span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> arr1_index = left;</span><br><span class="line">	<span class="keyword">int</span> arr2_index = mid+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (arr1_index &lt; mid+<span class="number">1</span> &amp;&amp; arr2_index &lt; right + <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[arr1_index] &lt; arr[arr2_index])</span><br><span class="line">		&#123;</span><br><span class="line">			result.push_back(arr[arr1_index]);</span><br><span class="line">			arr1_index++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			result.push_back(arr[arr2_index]);</span><br><span class="line">			arr2_index++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (arr1_index &lt; mid+<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		result.push_back(arr[arr1_index]);</span><br><span class="line">		arr1_index++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (arr2_index &lt; right + <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		result.push_back(arr[arr2_index]);</span><br><span class="line">		arr2_index++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		arr[i + left] = result[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (left &lt; right)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">		MergeSort(arr, left, mid);</span><br><span class="line">		MergeSort(arr, mid + <span class="number">1</span>, right);</span><br><span class="line">		Merge(left, right);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">		arr.push_back(rand() % <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">	MergeSort(arr, <span class="number">0</span>, arr.size() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>, arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​                        전역변수를 통해 전역범수 안에서 정렬을 수행하는 병합 정렬</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xyom.github.io/2017/12/28/병합 정렬/" data-id="cjdj0kc35004bltqrcqf6qog9" class="article-share-link">공유</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/병합-정렬/">병합 정렬</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-퀵 정렬" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/28/퀵 정렬/" class="article-date">
  <time datetime="2017-12-28T10:51:33.232Z" itemprop="datePublished">2017-12-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Programming/">Programming</a>►<a class="article-category-link" href="/categories/Programming/Algorithm/">Algorithm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/28/퀵 정렬/">퀵 정렬</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://www.geeksforgeeks.org/wp-content/uploads/gq/2014/01/QuickSort2.png" alt=""></p>
<p> 퀵 정렬은 O(nlogn)의 시간복잡도를 가지는 빠른 정렬로써 데이터를 기준이 되는 숫자보다 작은 숫자와 큰 숫자로  왼쪽 오른쪽 분류해나가는 방식으로 동작한다. 여기서 기준이 되는 숫자를 pivot이라고 하고 이 pivot을 잡는 방법에 대해 설명하겠다.</p>
<p> pivot의 선택은 어느 숫자로 잡아도 상관이 없다. 가장 처음 or 마지막 or 중간 등 어떠한 숫자로 잡아도 상관없지만 편의상 처음이나 중간, 마지막을 주로 사용한다. 위의 그림에서는 마지막을 피벗으로 잡았지만 코드에서는 가장 처음의 원소를 피벗으로 잡았다.</p>
<p> 피벗을 잡게되면 이 피벗의 값을 기준으로 원소들의 크기를 비교하여 작은 값은 왼쪽에 더 큰 값을 오른쪽에 오도록 정렬한 뒤 이 피벗의 위치 값을 리턴한다.</p>
<p> 이 리턴된 피벗값을 기준으로 왼쪽 범위, 오른쪽 범위로 다시 정렬할 대상이 나누어 지게 되고 다시 피벗을 잡고 분류하는 과정을 반복해 나간다. 범위의 left 인덱스와 right 인덱스의 값이 같아지면 결국 크기가 1인 배열로 최종적으로 나뉘어진 것이므로 더이상 진행하지 않는다.</p>
<p> 위 그림의 예제를 보면 첫번째 단계에서 70을 기준으로 오른쪽 왼쪽 배열을 나누었고 70보다 더 작은 숫자는 {10 30 40 50}, 큰숫자는 {90,80}으로 나뉘어졌고 이 과정을 반복하는 것을 볼 수 있다. 퀵정렬의 시간복잡도가 nlong인 이유는 범위를 배열의 크기가 1일때 까지 나누는과정을 반복하는 logn과 피벗을 기준으로 분류하는 작업이 n이므로 nlogn의 시간복잡도를 가지게 된다.</p>
<p> 퀵 정렬은 nlogn의 속도로 빠른 정렬에 속하지만 이미 정렬되어 있는 숫자에 대해 적용하면 O(n2)의 시간복잡도를 가질 수 있으므로 모두 정렬된 경우와 같은 상황에서는 효율을 기대할 수 없다.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = arr[a];</span><br><span class="line">	arr[a] = arr[b];</span><br><span class="line">	arr[b] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pivot</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p_value = arr[left];</span><br><span class="line">	<span class="keyword">int</span> p_index = left;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt;= right; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[i] &lt; p_value)</span><br><span class="line">		&#123;</span><br><span class="line">			p_index++;</span><br><span class="line">			swap(arr, i, p_index);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	swap(arr,left,p_index);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> p_index;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (left &lt; right)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> mid = pivot(arr, left, right);</span><br><span class="line">		quickSort(arr, left, mid - <span class="number">1</span>);</span><br><span class="line">		quickSort(arr, mid + <span class="number">1</span>, right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">		arr.push_back(rand() % <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">	quickSort(arr, <span class="number">0</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>, arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xyom.github.io/2017/12/28/퀵 정렬/" data-id="cjdj0kc3e004oltqrw7917tmr" class="article-share-link">공유</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/퀵-정렬/">퀵 정렬</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-백준 11066 파일합치기" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/26/백준 11066 파일합치기/" class="article-date">
  <time datetime="2017-12-26T08:26:07.660Z" itemprop="datePublished">2017-12-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Programming/">Programming</a>►<a class="article-category-link" href="/categories/Programming/Algorithm/">Algorithm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/26/백준 11066 파일합치기/">백준 11066 파일합치기</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="http://52.79.231.100:4000/images/1514275667416.PNG" alt=""></p>
<p> 파일 합치기 문제는 인접한 파일을 합치고 합쳐진 파일을 다른 파일과 합쳐나가며 이 파일을 합치는데 필요한 비용을 최소화 하는 문제이다. 이 문제는 동적 계획법으로 풀 수 있다.</p>
<p> 이 부분에 대한 개념은 구간에 대한 개념으로 나누어 보면 쉽게 풀 수 있다. 1 ~ n까지의 구간이 있다고 하면 1~n까지의 구간의 합을 최소로 만드는 것은 임의의 j에 대하여 1~j, j+1 ~ n 까지의 구간을 합쳐서 그 합을 최소로 만드는 것과 같다. 즉 구간 i~j라고 함은 i~j의 구간의 파일의 크기의 최소 합이다.</p>
<p> 이에 대한 점화식을 세우면 for(int j=1;j&lt;=n;j++) cost(1)(n) = min(cost(1)(n),cost(1)(j) + cost(j+1)(n))으로 부분으로 나올 수 있는 모든 구간들에 대해 확인하고 그 최소 값을 찾는다. 또한 크기가 큰 구간을 찾기 위해서는 크기가 작은 구간의 값들을 알아햐 하므로 크기가 작은 값들부터 계산해서 점차적으로  값을 계산해 나간다.</p>
<p> <img src="http://52.79.231.100:4000/images/1514276698195.PNG" alt=""></p>
<p> 부분 구간들 또한 더 작은 부분 구간들의 최소합으로 이루어진 결과이므로 결과적으로 최소 + 최소를 만족하여 답을 구할 수 있게 된다.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 987654321</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> testCase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum[<span class="number">502</span>];</span><br><span class="line"><span class="keyword">int</span> cost[<span class="number">502</span>][<span class="number">502</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("input.txt", "r", stdin);</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;testCase);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; testCase; t++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> numb;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;numb);</span><br><span class="line">			sum[i] = sum[i - <span class="number">1</span>] + numb;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; n; k++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - k; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				cost[i][i + k] = INF;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; i + k ; j++)</span><br><span class="line">				&#123;</span><br><span class="line">					cost[i][i + k] = min(cost[i][i + k], cost[i][j] + cost[j+<span class="number">1</span>][i + k]);</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				cost[i][i + k] += sum[i + k] - sum[i - <span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cost[<span class="number">1</span>][n]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xyom.github.io/2017/12/26/백준 11066 파일합치기/" data-id="cjdj0kc1u002lltqruzrmzldg" class="article-share-link">공유</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Dynamic-Programming/">Dynamic Programming</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; 이전</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/">다음 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">카테고리</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CS/">CS</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/CS/Database/">Database</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CS/ETC/">ETC</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CS/JAVA/">JAVA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CS/네트워크/">네트워크</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CS/운영체제/">운영체제</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CS/컴퓨터구조/">컴퓨터구조</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/InterView/">InterView</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Programming/">Programming</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Programming/Algorithm/">Algorithm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Programming/DataStructure/">DataStructure</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Programming/JavaScript/">JavaScript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Programming/Node-js/">Node js</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">태그</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ARP란/">ARP란</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CPU-스케줄링/">CPU 스케줄링</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Database/">Database</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DisJointSet/">DisJointSet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dynamic-Programming/">Dynamic Programming</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HashTable/">HashTable</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/InterView/">InterView</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linked-List/">Linked List</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/">Node js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PriorityQueue/">PriorityQueue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Queue/">Queue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Rest-API/">Rest API</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Stack/">Stack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/boj-5525/">boj 5525</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/가비지-컬렉션이란/">가비지 컬렉션이란</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/객체-지향-프로그래밍-JAVA/">객체 지향 프로그래밍 / JAVA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/백준-13911-집-구하기/">백준 13911 집 구하기</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/백준-14888-연산자-끼워-넣기/">백준 14888 연산자 끼워 넣기</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/백준-1654-랜선-자르기/">백준 1654 랜선 자르기</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/백준-2250-트리의-높이와-너비/">백준 2250 트리의 높이와 너비</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/백준-2579-계단-오르기/">백준 2579 계단 오르기</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/백준-2661-좋은-수열/">백준 2661 좋은 수열</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/백준-5525/">백준 5525</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/백준-9933-민균이의-비밀번호/">백준 9933 민균이의 비밀번호</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/백준-9935-문자열-폭발/">백준 9935 문자열 폭발</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/버블-정렬/">버블 정렬</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/병합-정렬/">병합 정렬</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/삽입-정렬/">삽입 정렬</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/선택-정렬/">선택 정렬</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/운영체제/">운영체제</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/퀵-정렬/">퀵 정렬</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/폴링-인터럽트-DMA/">폴링 , 인터럽트, DMA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/프로세스/">프로세스</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/프로세스-쓰레드-동기화/">프로세스/ 쓰레드 동기화</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/하노이탑-알고리즘/">하노이탑 알고리즘</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/허프만-코드-알고리즘/">허프만 코드 알고리즘</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">태그 클라우드</h3>
    <div class="widget tagcloud">
      <a href="/tags/ARP란/" style="font-size: 10px;">ARP란</a> <a href="/tags/Algorithm/" style="font-size: 20px;">Algorithm</a> <a href="/tags/CPU-스케줄링/" style="font-size: 10px;">CPU 스케줄링</a> <a href="/tags/Database/" style="font-size: 13.33px;">Database</a> <a href="/tags/DisJointSet/" style="font-size: 10px;">DisJointSet</a> <a href="/tags/Dynamic-Programming/" style="font-size: 10px;">Dynamic Programming</a> <a href="/tags/HashTable/" style="font-size: 10px;">HashTable</a> <a href="/tags/InterView/" style="font-size: 10px;">InterView</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Linked-List/" style="font-size: 10px;">Linked List</a> <a href="/tags/Node-js/" style="font-size: 16.67px;">Node js</a> <a href="/tags/PriorityQueue/" style="font-size: 10px;">PriorityQueue</a> <a href="/tags/Queue/" style="font-size: 10px;">Queue</a> <a href="/tags/Rest-API/" style="font-size: 10px;">Rest API</a> <a href="/tags/Stack/" style="font-size: 10px;">Stack</a> <a href="/tags/boj-5525/" style="font-size: 10px;">boj 5525</a> <a href="/tags/가비지-컬렉션이란/" style="font-size: 10px;">가비지 컬렉션이란</a> <a href="/tags/객체-지향-프로그래밍-JAVA/" style="font-size: 10px;">객체 지향 프로그래밍 / JAVA</a> <a href="/tags/백준-13911-집-구하기/" style="font-size: 10px;">백준 13911 집 구하기</a> <a href="/tags/백준-14888-연산자-끼워-넣기/" style="font-size: 10px;">백준 14888 연산자 끼워 넣기</a> <a href="/tags/백준-1654-랜선-자르기/" style="font-size: 10px;">백준 1654 랜선 자르기</a> <a href="/tags/백준-2250-트리의-높이와-너비/" style="font-size: 10px;">백준 2250 트리의 높이와 너비</a> <a href="/tags/백준-2579-계단-오르기/" style="font-size: 10px;">백준 2579 계단 오르기</a> <a href="/tags/백준-2661-좋은-수열/" style="font-size: 10px;">백준 2661 좋은 수열</a> <a href="/tags/백준-5525/" style="font-size: 10px;">백준 5525</a> <a href="/tags/백준-9933-민균이의-비밀번호/" style="font-size: 10px;">백준 9933 민균이의 비밀번호</a> <a href="/tags/백준-9935-문자열-폭발/" style="font-size: 10px;">백준 9935 문자열 폭발</a> <a href="/tags/버블-정렬/" style="font-size: 10px;">버블 정렬</a> <a href="/tags/병합-정렬/" style="font-size: 10px;">병합 정렬</a> <a href="/tags/삽입-정렬/" style="font-size: 10px;">삽입 정렬</a> <a href="/tags/선택-정렬/" style="font-size: 10px;">선택 정렬</a> <a href="/tags/운영체제/" style="font-size: 13.33px;">운영체제</a> <a href="/tags/퀵-정렬/" style="font-size: 10px;">퀵 정렬</a> <a href="/tags/폴링-인터럽트-DMA/" style="font-size: 10px;">폴링 , 인터럽트, DMA</a> <a href="/tags/프로세스/" style="font-size: 10px;">프로세스</a> <a href="/tags/프로세스-쓰레드-동기화/" style="font-size: 10px;">프로세스/ 쓰레드 동기화</a> <a href="/tags/하노이탑-알고리즘/" style="font-size: 10px;">하노이탑 알고리즘</a> <a href="/tags/허프만-코드-알고리즘/" style="font-size: 10px;">허프만 코드 알고리즘</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">아카이브</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">1월 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">12월 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">최근 포스트</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/01/31/백준 13459 째로탈출/">백준 13459 째로탈출</a>
          </li>
        
          <li>
            <a href="/2018/01/31/백준 12100 2048/">백준 12100 2048 easy</a>
          </li>
        
          <li>
            <a href="/2018/01/31/백준 1700 멀티탭 스케줄링/">백준 1700 멀티탭 스케줄링</a>
          </li>
        
          <li>
            <a href="/2018/01/31/백준 14500 테트로미노/">백준 14500 테트로미노</a>
          </li>
        
          <li>
            <a href="/2018/01/31/백준 5427 불/">백준 5427 불</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 SuHawn Yun<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>