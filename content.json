{"meta":{"title":"Gunner","subtitle":"Gunner","description":"My Tech Blog","author":"SuHawn Yun","url":"http://xyom.github.io"},"pages":[],"posts":[{"title":"프로세스","slug":"프로세스","date":"2018-01-01T11:10:28.675Z","updated":"2018-01-01T11:10:28.675Z","comments":true,"path":"2018/01/01/프로세스/","link":"","permalink":"http://xyom.github.io/2018/01/01/프로세스/","excerpt":"","text":"프로세스 프로세스란 실행중인 프로그램이다. 프로세스는 자신만의 Stack, Heap, Data, Code영역을 가진다. 프로세스는 운영체제에 의해 생성되고 스케줄링된다. 프로세스는 실행 과정중에서 I/O, Time Slice의 만료와 같은 상황에 따라 상태가 바뀌며 실행된다. 프로세스의 상태 프로세스의 상태는 크게 new, ready ,running, waiting, termiated로 볼 수 있다. new (생성) : 프로세스가 생성중인 상태이다. ready(준비) : 프로세스가 실행될 준비가 되어 있으며 준비 큐에서 실행되기를 기다리고 있는 상태이다. ready 큐에 있는 프로세스들은 단기스케줄러에 의해 디스 패치되어 cpu를 할당 받는다. running(실행) : 프로세스가 실행중인 상태이다. CPU를 할당받아 명령을 실행하는 상태이다. 이 경우 TimeSlice가 만료되면 인터럽트가 일어나 다시 ready 상태로 천이 되고 I/O 이벤트를 만나게 되면 I/O 이벤트에 대해 기다리는 wating 상태가 되고 완료되면 다시 ready 상태로 돌아간다. waiting(wait,sleep) : CPU를 할당받아도 지금 당장 실행할 수 없는 상태이다. 어떠한 입출력을 기다리거나 Sleep 상태이기 때문에 다른일을 처리할 수 없다. terminated(중단) : 프로세스가 모든 명령을 처리하여 중단된 상태이다. PCB PCB(Process Control Block)은 운영체제가 프로세스를 관리하기 위해 프로세스당 유지하는 정보이다. 프로세스 상태, PC, 프로세스 ID,레지스터, 메모리 위치정보 등을 저장한다. Context Switching을 하기 위해서는 PCB에 프로세스의 정보를 저장할 필요가 생긴다. A라는 프로세스를 실행하다가 B라는 프로세스를 실행할 때 A의 실행 정보를 저장함으로써 A가 수행하던 작업을 나중에 다시 이어나갈 수 있다. Context Switching 여러 프로세스들은 스케줄링 되고 CPU를 할당받아 자신의 Time Slice만큼 작업을 수행한다. 만약 Time Slice가 만료되어 자신의 수행 시간이 지났을 경우 새로 수행할 프로세스에게 CPU를 할당해야 하는데 이 과정에서 PCB에 프로세스의 정보를 저장하고 불러오는 과정을 Context Switching이라고 한다. 스케줄러(Scheduler) 스케줄러에는 장기 스케줄러, 중기 스케줄러, 단기 스케줄러가 있다. -&gt; 스케줄러는 어떠한 프로세스가 메모리를 할당 받을지, ready queue에서 대기하는지 등을 결정한다. 장기 스케줄러 -&gt; 장기 스케줄러는 new 상태의 프로세스 중 어떠한 프로세스들이 ready queue 상태에서 대기할지를 결정하는 스케줄러이다. 즉 동시에 몇개의 프로그램이 실행될지를 결정하는 스케줄러이다.(Ready 큐에 있는 프로세스들은 번갈아가면서 동시에 실행된다.) 디스크 -&gt; 메모리로의 프로세스를 결정한다. 보통 시분할 시스템에서는 장기스케줄러가 존재하지 않고 프로세스 생성시 바로 ready queue로 간다. ​ 중기 스케줄러 -&gt; 프로세스가 메모리상에 너무 많이 올라와 있을 경우 메모리 상에 있는 프로세스를 디스크 상으로 쫓아내는 작업을 한다.(swap out) ​ 단기 스케줄러 -&gt; 실제적으로 어떠한 프로세스가 cpu를 할당받는지를 결정한다. 스케줄링 알고리즘에 따라서 다음번에 실행될 프로세스를 결정한다.","categories":[{"name":"CS","slug":"CS","permalink":"http://xyom.github.io/categories/CS/"},{"name":"운영체제","slug":"CS/운영체제","permalink":"http://xyom.github.io/categories/CS/운영체제/"}],"tags":[{"name":"프로세스","slug":"프로세스","permalink":"http://xyom.github.io/tags/프로세스/"}]},{"title":"운영체제란","slug":"운영체제","date":"2018-01-01T11:10:28.631Z","updated":"2018-01-01T11:10:28.631Z","comments":true,"path":"2018/01/01/운영체제/","link":"","permalink":"http://xyom.github.io/2018/01/01/운영체제/","excerpt":"","text":"운영체제란? 운영체제란 컴퓨터 시스템의 하드웨어 자원을 관리하고 효율적으로 사용할 수 있도록 하는 소프트웨어를 말한다. 좁은 의미에서는 운영체제의 커널을 의미하며 넓은 의미에서는 시스템을 관리하는 시스템 유틸리티들을 포함한 개념을 말한다. 운영체제는 A 프로세스의 메모리가 B프로세스의 메모리 영역을 침범하지 않도록 관리하고 파일시스템, 네트워크,프로세스들을 관리한다. -&gt; 이는 모두 시스템 자원을 효율적으로 사용하여 최대의 성능을 내도록하고 사용자가 편리하게 사용할 수 있는 환경을 제공해 준다. 운영체제의 분류 운영체제는 동시 작업 가능 여부, 사용자의 수,처리 방식에 따라 이를 분류할 수 있다. 1. 동시 작업 가능여부 단일 작업(Single-Tasking) 한번에 하나의 작업만 처리할 수 있다. 예) MS-DOS는 하나의 작업을 끝낼 때 까지 다른 작업을 수행할 수 없다. 다중 작업(Multi-Tasking) 비슷한 개념으로 Multi Programming, Multi Proccessing 등이 있다. 동시에 두개 이상의 작업을 처리한다. 예) UNIX, WINDOWS는 한 명령의 수행이 끝나기 전에 다른 명령이나 프로그램을 수행할 수 있다. 2. 사용자의 수 단일 사용자(Single User) 운영 체제에 오로지 단 하나의 사용자로만 사용할 수 있다. 예) MS DOS 다중 사용자(Multi User) 운영 체제에 여러명의 사용자가 있을 수 있다. -&gt; 리눅스를 보면 root 사용자 이외에도 여러 권한을 가진 다수의 사용자가 컴퓨터에 접속할 수 있다. 3. 처리 방식 일괄 처리(batch) 작업의 요청을 한꺼번에 모아서 처리한다. -&gt; 은행의 정산시스템 같은 경우 월별로 모아서 한꺼번에 처리하는 것이 더욱 효율적이다. 일괄 처리를 하게 되면 시스템의 응답성은 떨어지지만 일괄처리를 하는 중에는 CPU의 사용량이 극대화된다. 시분할(Time Sharing) 여러 프로세스들은 동시에 수행되면서 일정한 시간(time slice)을 할당받아 수행된다. -&gt; 이로 인해 프로세스는 모두 동시에 실행되는 것 처럼 느껴진다. 실시간(RealTime OS) 정해진 시간 안에 어떤 일이 반드시 종료되어야 하는 것을 보장하는 OS이다. 운영체제가 하는일1. 메모리관리 프로세스가 실행되기 위해서는 메모리 상에 올라와 있어야 하는데 어떠한 프로세스가 메모리에 올라오고 이 프로세스의 페이지의 어느 부분이 메모리에 올라와야 하는지 등을 관리한다. 2. 프로세스 관리 프로세스의 생성/삭제에 대한 부분을 관리하고 어떠한 프로세스가 cpu를 할당받아 실행될지를 결정한다. 프로세스간의 동기화 문제를 해결해준다. 교착상태를 방지하는 기법을 제공해준다. 3. 장치 관리 특정 하드웨어 장치를 쉽게 사용/제거 할 수 있게 해주고 장치간의 입출력을 제어해준다. 4. 파일 관리 파일의 생성/쓰기/읽기에 관여한다. 파일의 물리적 저장 위치를 결정한다. 5. 시스템 보호 시스템의 사용자들에게 적절한 권한을 부여하여 권한이 없는 사용자의 접근을 막는다. 6. 네트워크7. 명령어 해석기와 시스템 관리","categories":[{"name":"CS","slug":"CS","permalink":"http://xyom.github.io/categories/CS/"},{"name":"운영체제","slug":"CS/운영체제","permalink":"http://xyom.github.io/categories/CS/운영체제/"}],"tags":[{"name":"운영체제","slug":"운영체제","permalink":"http://xyom.github.io/tags/운영체제/"}]},{"title":"컴퓨터 입출력","slug":"시스템버스","date":"2018-01-01T11:10:28.631Z","updated":"2018-01-01T11:10:28.631Z","comments":true,"path":"2018/01/01/시스템버스/","link":"","permalink":"http://xyom.github.io/2018/01/01/시스템버스/","excerpt":"","text":"인터럽트란 인터럽트는 컴퓨터에서 발생하는 특수한 제어신호로 인터럽트가 발생하게 되면 인터럽트 당한 시점의 레지스터와 pc값을 저장한 후 CPU의 제어를 인터럽트 처리 루틴으로 넘긴다. 인터럽트는 크게 하드웨어 인터럽트, 소프트웨어 인터럽트로 나뉘며 현대의 운영체제는 인터럽트 동작 방식을 통해 구동된다. 입/출력 장치의 입/출력의 과정에서도 인터럽트가 발생하며 CPU는 인터럽트가 발생했다는 것을 인지하여 입/출력이 완료되었음을 알아 차리게 된다. 인터럽트가 있기에 컴퓨터는 예외 상황이 발생하면 현재 하던 작업을 중단하고 서브루틴을 수행하여 우선적으로 인터럽트에 대하여 처리할 수 있게 된다. 만약 인터럽트가 없다면 컴퓨터는 매번 실행되는 일이 모두 끝날 때까지 기다려야 할 것이다. I/O 방식I/O 방식에는 크게 폴링, 인터럽트 방식, DMA 방식이 있으며 이 3가지에 대해서 알아보도록 하겠다. 폴링 방식 : 폴링 방식은 while문을 생각하면 쉽다. CPU에서 입출력이 완료 되었는지 주기적으로 입출력 장치의 버퍼를 확인한다. 가장 간단한 방식이지만 CPU가 주기적으로 확인해야 하는 방식이기 때문에 효율적이지 못하다. 인터럽트 방식: 인터럽트 방식은 컴퓨터에서 일어나는 인터럽트 신호를 통해 CPU에 입/출력이 완료되었음을 알려주는 방식이다. 입/출력이 발생하면 Device Controller에 연결되어 있는 Local Buffer에 데이터가 쌓이게 되고 이 Buffer가 가득차면 Device Controller는 인터럽트 신호를 발생시켜 CPU에 입/출력 작업이 완료되었음을 알린다. 이는 주기적으로 CPU가 확인해야하는 폴링 방식에 비해 효율적이다. ​ DMA 방식: DMA 방식은 DMA Controller에 입/출력에 대한 제어를 넘기고 메모리에 내용을 직접 읽고 쓰는 것을 의미한다. CPU에서 입/출력할 일이 생기게 되면 CPU는 입/출력을 수행할 메모리에 대한 주소의 값을 DMA에 넘겨주고 DMA에 제어권을 넘긴다. 이후 DMA는 입/출력 장치와 데이터를 주고 받으면서 모든 입/출력 과정이 끝났을 때 인터럽트를 발생시킨다. 이 방식은 Buffer가 쌓일 때마다 인터럽트를 발생시키는 방식보다 인터럽트가 덜 발생하기 때문에 효율적이다. -&gt; DMA는 입/출력 과정에서 데이터 버스의 사용이 필요하다. 하지만 CPU와 DMA가 동시에 데이터 버스에 대한 사용을 할 수 없기 때문에 CPU가 데이터 버스에 대한 사용권을 한 차례(Cycle)을 넘겨주는데 이를 Cycle Stealing이라고 한다. 동기 , 비동기 방식 입출력 동기 방식 : 동기 방식이란 입출력이 완료 될 때까지 아무 작업을 하지 않고 완료를 기다리는 것이다. 예를 들면 빨래를 세탁기에 널었는데 세탁기가 빨래를 모두 할 때 까지 다른일을 하지 않고 기다리는 것으로 볼 수 있다. 프로그램의 입출력 방식이 동기 방식으로 수행되면 코드는 수행되다가 해당 입출력이 완료되어 결과를 반환할때까지 멈추어 있게 된다. ​ 비동기 방식: 비동기 방식은 입출력에 대하여 시켜놓고 다른일을 하는 것을 말한다. 위에서 빨래를 하면서 아무일도 하지 않고 기다렸다면 빨래를 하도록 해놓고 나는 컴퓨터도 하고 요리도 하고 다른일을 하다가 완료되었으면 이에 대해 통보받는 것을 의미한다. 비동기함수는 결과를 즉시 리턴하며 작업이 완료되었음을 알려준다.","categories":[{"name":"CS","slug":"CS","permalink":"http://xyom.github.io/categories/CS/"},{"name":"컴퓨터구조","slug":"CS/컴퓨터구조","permalink":"http://xyom.github.io/categories/CS/컴퓨터구조/"}],"tags":[{"name":"폴링 , 인터럽트, DMA","slug":"폴링-인터럽트-DMA","permalink":"http://xyom.github.io/tags/폴링-인터럽트-DMA/"}]},{"title":"CPU 스케줄링","slug":"스케줄링","date":"2018-01-01T11:10:28.591Z","updated":"2018-01-01T11:10:28.591Z","comments":true,"path":"2018/01/01/스케줄링/","link":"","permalink":"http://xyom.github.io/2018/01/01/스케줄링/","excerpt":"","text":"스케줄링 스케줄링이랑 CPU에서 어떠한 프로세스가 실행되어야 할지 결정하는 작업이다. 적절한 스케줄링을 해야만 컴퓨터 작업의 효율성이 향상되고 반환시간이 단축된다. 스케줄링을 하는데 고려해야 할 요소는 CPU 이용률 , 처리량, 반환시간,대기 시간, 응답시간이 있다. 스케줄링은 수행되고 있는 프로세스를 뺏을 수 있냐 없냐에 따라서 선점/비선점 스케줄링으로 구분된다. 비선점 스케줄링 비선점 스케줄링이란 현재 실행되고 있는 프로세스의 작업을 중단시키고 CPU의 이용을 빼앗을 수 없는 스케줄링이다. 대표적으로 FCFS, SJF, HRN, 우선순위 방식이 있다. FCFS (First Come First Served) 도착한 순서대로 스케줄링하는 가장 간단한 스케줄링 방식이다. 구현이 매우 쉽지만 우선순위가 높아 먼저 처리해야 하는 프로세스가 생겨도 먼저 처리할 수 없는 단점을 가지고 있다. 위의 그림에서 P0,P1,P2,P3순으로 도착 했으므로 순서대로 할당한다. SJF(Shortest Job First) SJF는 가장 짧은 서비스 시간을 갖는 프로세스를 가장 먼저 실행하는 스케줄링이다. 위 그림에서는 서비스 시간이 가장 짧은 순서대로 p1, p0 ,p3,p2 순으로 실행되며 모든 스케줄링 중에서 평균 반환시간이 가장 짧은 스케줄링이다. 하지만 짧은 수행시간을 가지는 작업이 계속 들어올 경우 상대적으로 긴 작업이 계속 뒤로 밀려나는 기아 현상이 발생할 수 있다. HRN(Highest Response Ratio Next) HRN은 SJF의 기아문제를 해결하기 위한 스케줄링 방법으로 (서비스 시간 + 대기시간) / 서비스 시간으로 나눈 값을 우선순위로 결정하여 이 값이 작은 프로세스를 우선적으로 수행한다. 우선순위 ( 비선점) 프로세스의 우선순위를 기준으로 우선순위가 높은 프로세스 순으로 스케줄링하는 기법이다. 비선점이기 때문에 높은 우선순위의 프로세스가 들어와도 현재 실행하는 프로세스는 계속 실행한다. 선점 스케줄링 선점 스케줄링은 CPU의 이용을 빼앗을 수 있는 스케줄링 기법이다. 비선점과 다르게 수행되고 있는 현재 프로세스를 중단시키고 다른 프로세스를 먼저 실행할 수 있다. RR(Roudn Robin) 라운들 로빈 방식은 시분할 방식으로 프로세스를 time slice만큼만 실행하도록 하는 방식이다. 위에서의 time slice 간격은 4로 4만큼 수행한뒤 다른 프로세스에게 cpu 이용을 넘겨주게 된다. 이 방식을 통하여 사용자는 프로세스 여러개가 동시에 수행되는 것 처럼 느낄 수 있다. SRT(Shortest Remaining First) SJF의 선점형 방식으로 SJF와 다른점은 더 짧은 작업이 들어왔을 경우 CPU를 빼앗을 수 있다는 점이다. Multilevel Queue(다단계 큐) 다단계 큐는 cpu의 ready 큐를 우선순위에 따라 여러개로 나눈 것이다. 각 큐는 독립적인 스케줄링 알고리즘을 가지고 각 큐에 대해 Cpu time을 적절히 할당하여 수행한다. 대표적으로 Foreground /Background 큐가 있는데 Foreground 큐는 RR 방식, Background 큐는 FCFS 방식 으로 스케줄링하며 80: 20의 CPU 이용시간을 가지고 작업을 처리하도록 구현한다. Multilevel Feedback Queue 다단계 피드백큐는 다단계 큐가 서로 다른 큐로 이동할 수 있는 큐의 구조이다. 위의 그림에서 quantum 즉 timeslice가 8/16인 큐와 fsfs인 큐가 존재한다. 프로세스는 처음 첫번째 큐에서 8의 큐를 할당받고 프로세스를 수행한다. 만약 다 완료하지 못하면 16인 큐로 이동하고 이마저도 완료하지 못하면 fcfs로 이동하여 순차적으로 처리하게 된다. -&gt; 이는 aging 기법을 이용한 것으로 프로세스가 시간이 지날수록 더 많은 수행시간을 가지게 함으로써 작업을 마칠 수 있도록 한다. 실시간 스케줄링 실시간 스케줄링은 작업이 마감시한 내에 완료되도록 스케줄링하는 것이다. 이 스케줄링을 적용하는 시스템은 다음과 같은 시스템들이 있다. 경성 실시간 시스템 - 작업이 마감시간내에 완료되지 않으면 치명적인 시스템 연성 실시간 시스템 - 작업이 마감시간내에 완료되지 않아도 되지만 시간이 지날수록 손해가 점점 커지는 시스템 RM(Rate Monotonic) 알고리즘 작업의 크기와 개수가 알려진 프로세스들이 주기적으로 발생하는 환경에서 사용한다. 프로세스는 각자 독립적이고 주기적으로 수행되는 환경에서 각 프로세스의 마감시한은 각자의 주기와 같다고 가정하고 주기가 짧을수록 높은 우선순위를 받게 된다. -&gt; 주기가 짧을수록 프로세스가 다시 발생하므로 빨리 수행해야 한다. RM은 선점 스케줄링 방식으로 높은 우선순위 작업에게 CPU를 뺴앗길 수 있다. EDF(Earlist Deadline First) 알고리즘 EDF 알고리즘은 프로세스의 마감시한이 가까워질수록 우선순위를 높게 부여하는 선점 방식의 동적 스케줄링이다. EDF 기법은 우선순위에 의해 CPU를 뺏길 수 있다. 한 프로세스의 실행이 완료되면 마감시간이 가장 가까운 것을 찾아 스케줄링 한다. 모든 프로세스가 주기적일 필요가 없으며 주기가 있을 경우 마감시간을 주기로, 그렇지 않을 경우 마감시간을 명시적으로 알려주어야 한다.","categories":[{"name":"CS","slug":"CS","permalink":"http://xyom.github.io/categories/CS/"},{"name":"운영체제","slug":"CS/운영체제","permalink":"http://xyom.github.io/categories/CS/운영체제/"}],"tags":[{"name":"CPU 스케줄링","slug":"CPU-스케줄링","permalink":"http://xyom.github.io/tags/CPU-스케줄링/"}]},{"title":"프로세스/스레드 동기화","slug":"프로세스 동기화","date":"2018-01-01T11:10:28.579Z","updated":"2018-01-01T11:10:28.579Z","comments":true,"path":"2018/01/01/프로세스 동기화/","link":"","permalink":"http://xyom.github.io/2018/01/01/프로세스 동기화/","excerpt":"","text":"프로세스 동기화 동기화란 병렬적으로 수행되는 작업들에 대해 자원에의 접근에 대한 순서를 정하는 과정을 말한다. 여러개의 프로세스나 쓰레드의 경우 동시에 특정 자원에 대한 접근이 발생할 수 있는데 이 과정에서 자원에 대해 동시 접근을 허용해 버린다면 예기치 못한 결과를 발생시킬 수 있다. 1234567int x = 10;public int cal(int a)&#123; x = a+1; &#125; Thread A와 Thread B가 전역변수 x에 대해 cal(x)를 동시에 수행했다고 가정해보자 사용자는 cal(x)를 두번 호출해서 12의 결과를 얻기를 원했다 하지만 Thread의 수행 순서는 예측할수 없기 때문에 Thread A와 Thread B가 모두 cal(x)를 호출하여 전역 변수 x의 을 자신의 local 변수 a에 복사하였다. 이 경우 Thread A와 Thread B는 10에 대하여 +1한값을 x에 집어넣기 때문에 x에는 최종적으로 11의 값이 들어가게 된다. -&gt; 두 쓰레드의 실행 순서가 보장되지 않았기 때문에 예상한 결과와 다른 결과를 나타내었다. 이렇게 예상치 못한 결과에 대하여 방지하고 한정된 자원에 대해 접근 순서를 보장하는 것을 동기화라고 한다. 임계구역 임계 구역 (Critical Section)이란 동시에 접근하는 것을 제한해야 하는 구역이다. 즉 쓰레드나 프로세스에 의해 한번에 한 프로세스 or 스레드가 접근하기를 원하는 구역이다. Mutex의 경우 락을 걸고 락을 푸는 사이의 영역이 임계구역이 된다. 임계구역은 자원에 대한 접근이나 연산이 동시에 이루어지지 않아야 하는 구역에 대하여 설정한다. ##Mutex vs SemaPhore 뮤텍스와 세마포어는 동기화를 위한 도구이다. 뮤텍스와 세마포어는 흔히들 말하는 화장실에 들어가는 키라고 말할 수 있다. 화장실에는 한번에 한명밖에 들어갈 수 없기 때문에 키를 획득한 사람만 들어갈 수가 있다. 뮤텍스와 세마포어의 차이라 함은 이 키에 대한 개수에서 차이가 있다. Mutex는 키가 1개이기 때문에 화장실에 한번에 한명 들어갈 수 있지만 세마포어는 키가 여러개여서 여러명이 들어갈 수 있다. 뮤텍스와 세마포어를 구현하는 방식은 Busy - wait를 통해 키를 획득할때 까지 빈 while문을 실행하는 방법과 프로세스의 상태를 sleep으로 전환시킨 뒤 실행해야 할 때 wake up 시켜 ready queue에 집어넣는 방법이 있다. Busy - waiting123456789101112131415161718int key = 0;int x = 10;public void lock()&#123; while(key &lt; 0)&#123;&#125; key--;&#125;public void unlock()&#123; key = 0;&#125;public void calc(int a)&#123; lock(); x = a+1; unlock();&#125; Busy -waiting은 key를 획득하지 못하면 while문을 계속해서 돌게 된다. 위의 코드에서는 key의 값이 0일때 임계영역에 들어갈 수 있다. 하지만 쓰레드는 순서에 대한 보장이 없으므로 key 값을 읽었을 때 동시에 여러 스레드가 0값을 읽을 가능성이 있다. 이에 대한 해결방법은 하드웨어적인 방법을 이용한 test - and - set 명령어를 사용하는 것이다. test and set은 변수를 읽는 중에 다른 쓰레드가 덮어 썼는지 확인하고 다시 읽기 때문에 이 문제를 해결할 수 있으며 많은 뮤텍스 세마포어가 test and set을 이용하여 구현한다. Sleep - wake up12345typedef struct&#123; int value; struct process *L;&#125;semaphore; Sleep - wake up 방식은 위의 방식에서 while문 대신 해당 프로세스를 sleep 시킨뒤 sleep 대기 큐에 집어넣고 완료하면 꺼내는 방식을 이용해 구현한다. Busy-wait 방식과 Sleep wait 방식의 효율성을 비교하면 평균적으로 Sleep wait 방식이 더욱 좋다. Busy- wait의 경우 기다리는 동안 while문으로 회전하기 때문에 cpu의 쓸데 없는 사용이 생겨나게 된다. 하지만 Sleep wait 방식의 경우 프로세스의 상태를 변경시키고 ready queue에 넣기 때문에 wait queue에서 ready queue로 비용이 든다. 따라서 cpu 사용량이 짧을경우 busy-wait 방식이 더욱 빠르다고 한다.","categories":[{"name":"CS","slug":"CS","permalink":"http://xyom.github.io/categories/CS/"},{"name":"운영체제","slug":"CS/운영체제","permalink":"http://xyom.github.io/categories/CS/운영체제/"}],"tags":[{"name":"프로세스/ 쓰레드 동기화","slug":"프로세스-쓰레드-동기화","permalink":"http://xyom.github.io/tags/프로세스-쓰레드-동기화/"}]},{"title":"Rest API란","slug":"Rest API","date":"2017-12-31T09:16:30.420Z","updated":"2017-12-31T09:16:30.420Z","comments":true,"path":"2017/12/31/Rest API/","link":"","permalink":"http://xyom.github.io/2017/12/31/Rest API/","excerpt":"","text":"REST(REpresentational State Transfer)란 HTTP 통신에 있어서 자원에 대한 조회, 변경, 삽입, 삭제 요청을 자원(Uri)과 행위(Method)로 표현하여 설계하는 방식을 말한다. REST에는 대표적으로 GET,POST ,PUT, DELETE METHOD가 있으며 자원에 대해 이 METHOD 방법에 따라 서버에서 수행하는 동작이 달라지도록 설계한다. 예를들어 http://서버:8080/member/1024를 GET 방식으로 호출한다는 것은 회원번호가 1024번인 멤버의 정보를 조회하겠다는 것을 의미한다. 똑같은 방식으로 이를 DELETE 방식으로 호출하게 되면 1024인 멤버의 정보를 삭제하겠다는 것을 의미하고 PUT 방식으로 호출하면 Body의 내용에 보낸 정보를 바탕으로 1024인 멤버의 정보를 수정하겠다는 것을 의미한다. 이렇게 자원에 대해서는 Uri로 표현하고 이에 대한 행동을 Method로 표현하면 표현의 의미가 분명해지고 Rest api 규칙을 지켜서 설계된 api에 대하여 Restful 한 api라고 말한다. 설계의 규칙 리소스와 행위를 명시적이고 직관적으로 분리한다. http://서버:8080/delete/member와 같이 uri안에 행위를 포함하는 표현이 있어서는 안된다. 행위는 GET(조회),POST(삽입),PATCH(일부 수정),PUT(객체 전체 수정),DELETE(삭제),HEAD(Body없이 헤더만 받음), OPTIONS(해당 리소스에 가능한 operation을 응답) 등으로 표현한다. ​ Message는 Header와 Body를 명확하게 구분하여 분리해 사용한다. Entity에 대한 내용은 Body에 담아 전송한다. -&gt; 수정하거나 삽입하려는 정보에 대한 내용은 Body에 담아 전송한다. API 버전 정보,MIME 타입 등은 header에 담는다. ​ 장점 REST API의 장점이라고 하면 API의 요청 방식 자체로 API가 어떤식으로 동작하는지 명확하게 알 수 있고 인가된 요청자들에 대해 언제 어디서나 데이터를 제공할 수 있다. -&gt; Open Api를 제공하기가 쉽다.","categories":[{"name":"CS","slug":"CS","permalink":"http://xyom.github.io/categories/CS/"},{"name":"ETC","slug":"CS/ETC","permalink":"http://xyom.github.io/categories/CS/ETC/"}],"tags":[{"name":"Rest API","slug":"Rest-API","permalink":"http://xyom.github.io/tags/Rest-API/"}]},{"title":"객체 지향 프로그래밍","slug":"객체지향 프로그래밍이란","date":"2017-12-31T09:16:30.404Z","updated":"2017-12-31T09:16:30.404Z","comments":true,"path":"2017/12/31/객체지향 프로그래밍이란/","link":"","permalink":"http://xyom.github.io/2017/12/31/객체지향 프로그래밍이란/","excerpt":"","text":"객체 지향 프로그래밍이란 실세계에서의 개념을 추상화하여 프로그래밍 상의 객체로 옮겨 놓는 방식으로 코드를 작성하는 방법을 말한다. 예를 들면 자동차라는 객체를 프로그래밍 하려면 자동차의 특성과 기능을 추려 이를 프로그래밍 할 수 있다. 자동차는 바퀴,헤드라이트, 핸들, … 등을 가지고 전진, 후진, 방향 전환 등의 기능을 가지고 있다. 이러한 특성과 기능을 모아 자동차라는 객체 클래스를 만들면 추가적인 특성을 가진 자동차 객체를 코딩하거나 자동차 객체를 여러개 생성하게 될 때 등등 코드를 재사용률이 커진다. 객체 지향 프로그래밍에는 4가지 특성과 5가지의 설계원칙이 있다. 객체지향 4가지 특성 추상화 - 추상화란 현실 세계의 객체의 공통된 특징과 기능을 추출하는 것을 의미한다. 동물은 사자, 원숭이, 코끼리 등등 많은 것이 존재하지만 이 동물들의 기본적인 특성과 기능을 모아 동물이라는 클래스를 정의하는 것을 추상화라고 한다. 동물은 모두 호흡을하고 심장을가지고 있으며 움직인다라는 특성과 기능을 가지고 있는데 이러한 것들을 한군데 모아 정의하는 것을 의미한다. ​ 다형성 - 다형성에는 오버로딩과 오버라이딩이 있다. 똑같은 이름의 함수여도 함수의 인자의 갯수나 타입, 상속 받은 객체에서의 오버라이딩에 대해서 다르게 동작하는 것을 의미한다. 오버로딩은 파라미터의 개수나 타입이 다른 함수를 정의하는 것을 의미한다. 예를 들어 두 정수를 더하는 public void sum(int a,int b)라는 함수를 정의했다고 하면 두 실수를 더하기 위한 함수인 public void sum(double a,double b)함수를 정의할 수 있다. 이 함수는 똑같은 이름으로 호출하지만 집어넣는 인자의 타입에 따라 다른방식으로 동작할 수 있다. 오버라이딩은 상속에 의해 부모가 가진 함수를 재정의 하여 사용하는 것을 의미한다. 부모 객체가 ‘안녕 나는 부모’라는 메시지를 출력하는 say()라는 함수를 가지고 있다고 하면 자식 객체는 부모 객체를 상속받으면서 이 함수에 대해 오버라이딩을 하여 ‘안녕 나는 자식’이라는 메시지를 출력하도록 변경할 수 있다. ​ 상속성 - 상속성은 부모 객체의 특성을 자식이 물려받는 것을 의미한다. 상속을 통해 부모가 가진 기능에 대하여 물려받아 사용할 수 있다. 예를 들어 자동차라는 클래스를 상속받은 슈퍼카 클래스는 기본 기능인 전진, 후진, 방향 전환 등의 기능을 모두 물려받고 자신의 특성인 부스트, 드리프트 기능등 자신의 특징만 추가하면된다. ​ 캡슐화 - 캡슐화란 클래스가 동작하는 것에 대해 사용자가 그 내부 동작을 모르게 동작한다는 것을 의미한다. 예를 들어 환자는 감기약이라는 캡슐 알약 하나를 먹지만 캡슐 알약에는 항생제, 수면제, 등등 많은 작용을 하는 성분들이 들어가 있고 작용을 하지만 환자는 이를 알 수 없다. 이처럼 클래스는 자신이 동작하는 것에 대해 사용자가 알 필요가 없이 동작하는 것을 캡슐화라고 한다. 객체지향 5가지 설계 원칙 SRP(Single Responsibility Principle) 단일 책임 원칙 클래스는 단 하나의 기능을 가지고 클래스가 제공하는 모든 서비스는 그 하나의 기능을 수행하는 데 집중해 있어야 한다. OCP(Open - Closed Principle) 개방 폐쇄의 원칙 확장에는 열려있고 변경에는 닫혀있어야 한다. LSP(Liskov Substitution Principle) 리스코프 치환 원칙 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다. ISP(Interface Segregation Principle) 인터페이스 분리 원칙 인터페이스는 그 인터페이스를 사용하는 사용자 기준으로 분리해야 한다. DIP(Dependency Inversion Principle) 의존 역전의 법칙 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다. 5가지 설계 원칙 참고","categories":[{"name":"CS","slug":"CS","permalink":"http://xyom.github.io/categories/CS/"},{"name":"JAVA","slug":"CS/JAVA","permalink":"http://xyom.github.io/categories/CS/JAVA/"}],"tags":[{"name":"객체 지향 프로그래밍 / JAVA","slug":"객체-지향-프로그래밍-JAVA","permalink":"http://xyom.github.io/tags/객체-지향-프로그래밍-JAVA/"}]},{"title":"선택 정렬","slug":"선택 정렬","date":"2017-12-28T10:51:33.284Z","updated":"2017-12-28T10:51:33.284Z","comments":true,"path":"2017/12/28/선택 정렬/","link":"","permalink":"http://xyom.github.io/2017/12/28/선택 정렬/","excerpt":"","text":"선택정렬은 데이터의 원소중에 가장 작은 최솟값의 인덱스를 찾은뒤 이를 교환해 주는 방법으로 동작한다. 위의 첫번째 단계를 보면 1이라는 최소 원소를 찾은 뒤 가장 이를 8의 원소의 위치와 교환해 주어 가장 최소의 값을 앞에 위치 시키는 것으로 볼 수 있다. 그 다음 최소값을 찾으면 3을 찾았고 그 다음 최솟값이 위치해야 할 5의 위치와 원소를 바꾸어주었다. 이와 같은 과정을 n-1번 반복하면서 최솟값을 찾는데 약 n의 시간이 소요되므로 O(n2)의 시간복잡도를 가진 정렬이다. 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;using namespace std;void swap(vector&lt;int&gt;&amp; arr, int a, int b)&#123; int temp = arr[a]; arr[a] = arr[b]; arr[b] = temp;&#125;void selectionSort(vector&lt;int&gt;&amp; arr)&#123; int m_index; for (int i = 0; i &lt; arr.size() - 1; i++) &#123; m_index = i; for (int j = i; j &lt; arr.size(); j++) &#123; if (arr[j] &lt; arr[m_index]) m_index = j; &#125; swap(arr, i, m_index); &#125;&#125;void main()&#123; srand((unsigned int)time(NULL)); vector&lt;int&gt; arr; for (int i = 0; i &lt; 10; i++) arr.push_back(rand() % 100); selectionSort(arr); for (int i = 0; i &lt; 10; i++) printf(\"%d \", arr[i]);&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://xyom.github.io/categories/Programming/"},{"name":"Algorithm","slug":"Programming/Algorithm","permalink":"http://xyom.github.io/categories/Programming/Algorithm/"}],"tags":[{"name":"선택 정렬","slug":"선택-정렬","permalink":"http://xyom.github.io/tags/선택-정렬/"}]},{"title":"삽입 정렬","slug":"삽입 정렬","date":"2017-12-28T10:51:33.256Z","updated":"2017-12-28T10:51:33.256Z","comments":true,"path":"2017/12/28/삽입 정렬/","link":"","permalink":"http://xyom.github.io/2017/12/28/삽입 정렬/","excerpt":"","text":"삽입 정렬은 정렬된 상태의 영역을 확대해 나가면서 그 다음의 후보가 삽입될 위치를 찾아 삽입한 뒤 그 다음 원소들을 밀어내는 방식으로 동작한다. 처음의 영역의 크기는 1로 가장 첫번째 원소만 포함한다. 위의 그림을 보면 5라는 원소가 크기 1인 영역에 속해 있고 2라는 다음 원소를 이 영역에 집어 넣는데 이 영역의 원소들과 비교해서 더 큰 숫자를 만나면 그 숫자의 전에 집어넣고 그 뒤로는 밀어낸다. 결과 2가 5의 앞으로 오고 5가 밀려나 2의 자리를 차지한다. 이와 같은 과정을 반복하게 되면 모든 원소들이 삽입되고 정렬된 결과를 얻게된다. 버블 정렬과 마찬가지로 O(n2)의 시간복잡도를 갖는다. 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;using namespace std;void swap(vector&lt;int&gt;&amp; arr, int a, int b)&#123; int temp = arr[a]; arr[a] = arr[b]; arr[b] = temp;&#125;void InsertSort(vector&lt;int&gt;&amp; arr)&#123; for (int i = 1; i &lt; arr.size(); i++) &#123; for (int j = 0; j &lt; i; j++) &#123; if (arr[i] &lt; arr[j]) &#123; int temp = arr[i]; memcpy(&amp;arr[j+1], &amp;arr[j], sizeof(int*) *(i - j)); arr[j] = temp; &#125; &#125; &#125;&#125;void main()&#123; srand((unsigned int)time(NULL)); vector&lt;int&gt; arr; for (int i = 0; i &lt; 10; i++) arr.push_back(rand() % 100); InsertSort(arr); for (int i = 0; i &lt; 10; i++) printf(\"%d \", arr[i]);&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://xyom.github.io/categories/Programming/"},{"name":"Algorithm","slug":"Programming/Algorithm","permalink":"http://xyom.github.io/categories/Programming/Algorithm/"}],"tags":[{"name":"삽입 정렬","slug":"삽입-정렬","permalink":"http://xyom.github.io/tags/삽입-정렬/"}]},{"title":"버블 정렬","slug":"버블 정렬","date":"2017-12-28T10:51:33.256Z","updated":"2017-12-28T10:51:33.256Z","comments":true,"path":"2017/12/28/버블 정렬/","link":"","permalink":"http://xyom.github.io/2017/12/28/버블 정렬/","excerpt":"","text":"버블 정렬은 가장 큰 원소를 바깥쪽으로 밀어내는 방식으로 정렬하는 방식이다. 처음 원소부터 자신의 다음 원소와 비교하여 더 큰 숫자를 비교하며 더 큰 숫자를 교환하여 뒤로 밀어내는 방식으로 정렬을 한다. 위의 그림을 보면 첫번째 원소 9와 6을 보고 9가 더 크므로 9를 뒤로 밀어내고 그 다음으로 넘어가 9와 2를 비교해 9가 더크니 위치를 다시 바꾼다. 이와 같은 과정을 반복해 나가면 가장 큰 숫자가 가장 뒤로 위치하게 되고 다음번에 수행할 때는 그 다음 큰 숫자가 오게 되므로 마지막 전에 위치 시킨다. 12345678910111213141516171819202122232425262728293031323334#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;void BubbleSort(int* arr,int size)&#123; for (int i = 1; i &lt; size; i++) &#123; for (int j = 0; j &lt; size - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125;&#125;void main()&#123; srand((unsigned int)time(NULL)); int arr[10]; for (int i = 0; i &lt; 10; i++) arr[i] = rand()%1000; BubbleSort(arr, 10); for (int i = 0; i &lt; 10; i++) printf(\"%d \", arr[i]);&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://xyom.github.io/categories/Programming/"},{"name":"Algorithm","slug":"Programming/Algorithm","permalink":"http://xyom.github.io/categories/Programming/Algorithm/"}],"tags":[{"name":"버블 정렬","slug":"버블-정렬","permalink":"http://xyom.github.io/tags/버블-정렬/"}]},{"title":"병합 정렬","slug":"병합 정렬","date":"2017-12-28T10:51:33.232Z","updated":"2017-12-28T10:51:33.232Z","comments":true,"path":"2017/12/28/병합 정렬/","link":"","permalink":"http://xyom.github.io/2017/12/28/병합 정렬/","excerpt":"","text":"병합정렬은 퀵정렬과 대표되는 O(nlogn)의 시간복잡도를 가진 정렬로 최악에 O(n2)의 시간복잡도를 가지는 퀵정렬과 달리 모든 경우의 O(nlogn)의 시간복잡도를 가지는 정렬이다. 또한 퀵정렬이 분할해 나가면서 정렬하는 방식이었다면 병합정렬은 모두 분할한 뒤 그 결과를 합치는 방법으로 약간의 차이가 있다. 병합정렬의 단점은 병합된 결과를 저장하기 위한 배열이 필요하기 때문에 메모리를 많이 차지할 수 있다. 병합정렬을 하는 과정은 배열을 mid를 기준으로 크기가 1인 배열이 될 때 까지 나누게 된다. 왼쪽 오른쪽으로 나눈 결과는 정렬 과정을 거치며 합쳐지고 이 과정을 반복하여 정렬을 수행해 나간다. 나뉘어진 원소를 합치면서 정렬하는 과정은 두 배열의 원소의 크기를 비교해나가며 작은 순서로 정렬된 결과 배열에 집어 넣는 것이다. {2,5} {4,6} 이라는 배열이 존재하면 각각 비교할 서로의 인덱스를 선언한다. 그리고 그 인덱스에 해당하는 아이템을 비교하고 더 작으면 결과 배열에 넣고 더 작았던 쪽 배열의 인덱스를 증가시킨다. 이 과정을 반복하고 마지막에 남은 원소들을 모두 끝에 넣어주게 되면 정렬된 결과가 나오게 된다. 이 과정이 반복되면서 정렬된 왼쪽, 오른쪽 배열들이 다시 합쳐지면서 정렬되어 최종으로 모두 정렬된 결과가 나오게 된다. 아래의 코드에서 MergeSort1은 결과를 저장하기 위해 배열을 선언한 것이고 MergeSort2는 배열 내에서 정렬을 수행한 코드이다. MergeSort11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;using namespace std;vector&lt;int&gt; Merge(vector&lt;int&gt; arr1, vector&lt;int&gt; arr2)&#123; vector&lt;int&gt; result; int arr1_index = 0; int arr2_index = 0; while (arr1_index &lt; arr1.size() &amp;&amp; arr2_index &lt; arr2.size()) &#123; if (arr1[arr1_index] &lt; arr2[arr2_index]) &#123; result.push_back(arr1[arr1_index]); arr1_index++; &#125; else &#123; result.push_back(arr2[arr2_index]); arr2_index++; &#125; &#125; while (arr1_index &lt; arr1.size()) &#123; result.push_back(arr1[arr1_index]); arr1_index++; &#125; while (arr2_index &lt; arr2.size()) &#123; result.push_back(arr2[arr2_index]); arr2_index++; &#125; return result;&#125;vector&lt;int&gt; MergeSort(vector&lt;int&gt;&amp; arr, int left, int right)&#123; if (left &lt; right) &#123; int mid = (left + right) / 2; vector&lt;int&gt; arr1 = MergeSort(arr, left, mid); vector&lt;int&gt; arr2 = MergeSort(arr, mid + 1, right); return Merge(arr1, arr2); &#125; else &#123; vector&lt;int&gt; temp; temp.push_back(arr[left]); return temp; &#125;&#125;void main()&#123; srand((unsigned int)time(NULL)); vector&lt;int&gt; arr; for (int i = 0; i &lt; 10; i++) arr.push_back(rand() % 100); vector&lt;int&gt; result = MergeSort(arr, 0, arr.size() - 1); for (int i = 0; i &lt; 10; i++) printf(\"%d \", result[i]);&#125; ​ 정렬된 결과를 따로 리턴하는 병합 정렬 MergeSort2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;using namespace std;vector&lt;int&gt; arr;void Merge(int left,int right)&#123; vector&lt;int&gt; result; int mid = (left + right) / 2; int arr1_index = left; int arr2_index = mid+1; while (arr1_index &lt; mid+1 &amp;&amp; arr2_index &lt; right + 1) &#123; if (arr[arr1_index] &lt; arr[arr2_index]) &#123; result.push_back(arr[arr1_index]); arr1_index++; &#125; else &#123; result.push_back(arr[arr2_index]); arr2_index++; &#125; &#125; while (arr1_index &lt; mid+1) &#123; result.push_back(arr[arr1_index]); arr1_index++; &#125; while (arr2_index &lt; right + 1) &#123; result.push_back(arr[arr2_index]); arr2_index++; &#125; for (int i = 0; i &lt; result.size(); i++) &#123; arr[i + left] = result[i]; &#125;&#125;void MergeSort(vector&lt;int&gt;&amp; arr, int left, int right)&#123; if (left &lt; right) &#123; int mid = (left + right) / 2; MergeSort(arr, left, mid); MergeSort(arr, mid + 1, right); Merge(left, right); &#125; &#125;void main()&#123; srand((unsigned int)time(NULL)); for (int i = 0; i &lt; 10; i++) arr.push_back(rand() % 100); MergeSort(arr, 0, arr.size() - 1); for (int i = 0; i &lt; 10; i++) printf(\"%d \", arr[i]);&#125; ​ 전역변수를 통해 전역범수 안에서 정렬을 수행하는 병합 정렬","categories":[{"name":"Programming","slug":"Programming","permalink":"http://xyom.github.io/categories/Programming/"},{"name":"Algorithm","slug":"Programming/Algorithm","permalink":"http://xyom.github.io/categories/Programming/Algorithm/"}],"tags":[{"name":"병합 정렬","slug":"병합-정렬","permalink":"http://xyom.github.io/tags/병합-정렬/"}]},{"title":"퀵 정렬","slug":"퀵 정렬","date":"2017-12-28T10:51:33.232Z","updated":"2017-12-28T10:51:33.232Z","comments":true,"path":"2017/12/28/퀵 정렬/","link":"","permalink":"http://xyom.github.io/2017/12/28/퀵 정렬/","excerpt":"","text":"퀵 정렬은 O(nlogn)의 시간복잡도를 가지는 빠른 정렬로써 데이터를 기준이 되는 숫자보다 작은 숫자와 큰 숫자로 왼쪽 오른쪽 분류해나가는 방식으로 동작한다. 여기서 기준이 되는 숫자를 pivot이라고 하고 이 pivot을 잡는 방법에 대해 설명하겠다. pivot의 선택은 어느 숫자로 잡아도 상관이 없다. 가장 처음 or 마지막 or 중간 등 어떠한 숫자로 잡아도 상관없지만 편의상 처음이나 중간, 마지막을 주로 사용한다. 위의 그림에서는 마지막을 피벗으로 잡았지만 코드에서는 가장 처음의 원소를 피벗으로 잡았다. 피벗을 잡게되면 이 피벗의 값을 기준으로 원소들의 크기를 비교하여 작은 값은 왼쪽에 더 큰 값을 오른쪽에 오도록 정렬한 뒤 이 피벗의 위치 값을 리턴한다. 이 리턴된 피벗값을 기준으로 왼쪽 범위, 오른쪽 범위로 다시 정렬할 대상이 나누어 지게 되고 다시 피벗을 잡고 분류하는 과정을 반복해 나간다. 범위의 left 인덱스와 right 인덱스의 값이 같아지면 결국 크기가 1인 배열로 최종적으로 나뉘어진 것이므로 더이상 진행하지 않는다. 위 그림의 예제를 보면 첫번째 단계에서 70을 기준으로 오른쪽 왼쪽 배열을 나누었고 70보다 더 작은 숫자는 {10 30 40 50}, 큰숫자는 {90,80}으로 나뉘어졌고 이 과정을 반복하는 것을 볼 수 있다. 퀵정렬의 시간복잡도가 nlong인 이유는 범위를 배열의 크기가 1일때 까지 나누는과정을 반복하는 logn과 피벗을 기준으로 분류하는 작업이 n이므로 nlogn의 시간복잡도를 가지게 된다. 퀵 정렬은 nlogn의 속도로 빠른 정렬에 속하지만 이미 정렬되어 있는 숫자에 대해 적용하면 O(n2)의 시간복잡도를 가질 수 있으므로 모두 정렬된 경우와 같은 상황에서는 효율을 기대할 수 없다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;using namespace std;void swap(vector&lt;int&gt;&amp; arr, int a, int b)&#123; int temp = arr[a]; arr[a] = arr[b]; arr[b] = temp;&#125;int pivot(vector&lt;int&gt;&amp; arr, int left, int right)&#123; int p_value = arr[left]; int p_index = left; for (int i = left + 1; i &lt;= right; i++) &#123; if (arr[i] &lt; p_value) &#123; p_index++; swap(arr, i, p_index); &#125; &#125; swap(arr,left,p_index); return p_index;&#125;void quickSort(vector&lt;int&gt;&amp; arr, int left, int right)&#123; if (left &lt; right) &#123; int mid = pivot(arr, left, right); quickSort(arr, left, mid - 1); quickSort(arr, mid + 1, right); &#125;&#125;void main()&#123; srand((unsigned int)time(NULL)); vector&lt;int&gt; arr; for (int i = 0; i &lt; 10; i++) arr.push_back(rand() % 100); quickSort(arr, 0, 9); for (int i = 0; i &lt; 10; i++) printf(\"%d \", arr[i]);&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://xyom.github.io/categories/Programming/"},{"name":"Algorithm","slug":"Programming/Algorithm","permalink":"http://xyom.github.io/categories/Programming/Algorithm/"}],"tags":[{"name":"퀵 정렬","slug":"퀵-정렬","permalink":"http://xyom.github.io/tags/퀵-정렬/"}]},{"title":"백준 11066 파일합치기","slug":"백준 11066 파일합치기","date":"2017-12-26T08:26:07.660Z","updated":"2017-12-26T08:26:07.660Z","comments":true,"path":"2017/12/26/백준 11066 파일합치기/","link":"","permalink":"http://xyom.github.io/2017/12/26/백준 11066 파일합치기/","excerpt":"","text":"파일 합치기 문제는 인접한 파일을 합치고 합쳐진 파일을 다른 파일과 합쳐나가며 이 파일을 합치는데 필요한 비용을 최소화 하는 문제이다. 이 문제는 동적 계획법으로 풀 수 있다. 이 부분에 대한 개념은 구간에 대한 개념으로 나누어 보면 쉽게 풀 수 있다. 1 ~ n까지의 구간이 있다고 하면 1~n까지의 구간의 합을 최소로 만드는 것은 임의의 j에 대하여 1~j, j+1 ~ n 까지의 구간을 합쳐서 그 합을 최소로 만드는 것과 같다. 즉 구간 i~j라고 함은 i~j의 구간의 파일의 크기의 최소 합이다. 이에 대한 점화식을 세우면 for(int j=1;j&lt;=n;j++) cost(1)(n) = min(cost(1)(n),cost(1)(j) + cost(j+1)(n))으로 부분으로 나올 수 있는 모든 구간들에 대해 확인하고 그 최소 값을 찾는다. 또한 크기가 큰 구간을 찾기 위해서는 크기가 작은 구간의 값들을 알아햐 하므로 크기가 작은 값들부터 계산해서 점차적으로 값을 계산해 나간다. 부분 구간들 또한 더 작은 부분 구간들의 최소합으로 이루어진 결과이므로 결과적으로 최소 + 최소를 만족하여 답을 구할 수 있게 된다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#pragma warning(disable:4996)#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define INF 987654321using namespace std;int testCase;int sum[502];int cost[502][502];int main()&#123; //freopen(\"input.txt\", \"r\", stdin); scanf(\"%d\", &amp;testCase); for (int t = 0; t &lt; testCase; t++) &#123; int n; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; int numb; scanf(\"%d\", &amp;numb); sum[i] = sum[i - 1] + numb; &#125; for (int k = 1; k &lt; n; k++) &#123; for (int i = 1; i &lt;= n - k; i++) &#123; cost[i][i + k] = INF; for (int j = i; j &lt; i + k ; j++) &#123; cost[i][i + k] = min(cost[i][i + k], cost[i][j] + cost[j+1][i + k]); &#125; cost[i][i + k] += sum[i + k] - sum[i - 1]; &#125; &#125; printf(\"%d\\n\", cost[1][n]); &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://xyom.github.io/categories/Programming/"},{"name":"Algorithm","slug":"Programming/Algorithm","permalink":"http://xyom.github.io/categories/Programming/Algorithm/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://xyom.github.io/tags/Dynamic-Programming/"}]},{"title":"백준 13911 집 구하기","slug":"백준 13911 집 구하기","date":"2017-12-26T06:23:23.879Z","updated":"2017-12-26T06:23:23.879Z","comments":true,"path":"2017/12/26/백준 13911 집 구하기/","link":"","permalink":"http://xyom.github.io/2017/12/26/백준 13911 집 구하기/","excerpt":"","text":"백준 13911 집 구하기 문제는 맥도날드인 vertex에서 거리가 x이하이고 &amp;&amp; 스세권의 vertex에서 거리가 y이하인 집을 찾는 문제이다. 단순히 맥도날드인 vertex, 스타벅스인 vertex에서 모두 다익스트라로 거리를 구해 만족하는 집들을 찾아내는 방법을 생각해도 맥도날드 또는 스타벅스의 수가 V-2개 까지 존재 할 수 있으므로 최악의 경우에 9998 * O(ElogV)를 해야하므로 시간초과가 발생한다. 하지만 이 문제에 대해 한번에 해결할 수 있는 방법이 있는데 맥도날드, 스세권으로 가는 cost가 0인 더미노드로 맥도날드 또는 스타벅스를 연결한뒤 다익스트라를 적용하는 것이다. 이 방법을 통해서 하게되면 맥도날드 1번, 스타벅스 1번의 다익스트라를 수행하는 것으로 문제를 풀 수 있다. 위의 그림처럼 각 정점으로의 거리의 배열 값을 구하게 되면 맥도날드, 혹은 스타벅스에서 각 정점으로의 최소거리를 구할 수 있고 조건에 따라 값을 출력해주기만 하면 된다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#pragma warning(disable:4996)#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define INF 987654321using namespace std;int v, e;vector &lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; adj;int m, x;int s, y;void daikstra(priority_queue&lt;pair&lt;int, int&gt;&gt;&amp; pq, vector&lt;int&gt;&amp; dist)&#123; while (!pq.empty()) &#123; int totCost = -pq.top().first; int current = pq.top().second; int nextSize = adj[current].size(); pq.pop(); for (int i = 0; i &lt; nextSize; i++) &#123; int next = adj[current][i].first; int nextCost = adj[current][i].second; if (totCost + nextCost &lt; dist[next]) &#123; dist[next] = totCost + nextCost; pq.push(make_pair(-dist[next], next)); &#125; &#125; &#125;&#125;int main()&#123; //freopen(\"input.txt\", \"r\", stdin); scanf(\"%d %d\", &amp;v, &amp;e); adj.resize(v + 1); for (int i = 0; i &lt; e; i++) &#123; int s, e, c; scanf(\"%d %d %d\", &amp;s, &amp;e, &amp;c); adj[s].push_back(make_pair(e, c)); adj[e].push_back(make_pair(s, c)); &#125; priority_queue&lt;pair&lt;int, int&gt;&gt; pq; vector&lt;int&gt; dist1(v + 1, INF); scanf(\"%d %d\", &amp;m, &amp;x); for (int i = 0; i &lt; m; i++) &#123; int t; scanf(\"%d\", &amp;t); dist1[t] = 0; pq.push(make_pair(0, t)); &#125; daikstra(pq, dist1); scanf(\"%d %d\", &amp;s, &amp;y); vector&lt;int&gt; dist2(v + 1, INF); for (int i = 0; i &lt; s; i++) &#123; int t; scanf(\"%d\", &amp;t); dist2[t] = 0; pq.push(make_pair(0, t)); &#125; daikstra(pq, dist2); int dis = INF; for (int i = 1; i &lt; v + 1; i++) if (dist1[i] != 0 &amp;&amp; dist2[i] != 0 &amp;&amp; dist1[i]&lt;=x &amp;&amp; dist2[i]&lt;=y &amp;&amp; dist1[i] + dist2[i] &lt; dis) dis = dist1[i] + dist2[i]; dis != INF ? printf(\"%d\\n\", dis) : printf(\"-1\\n\"); &#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://xyom.github.io/categories/Programming/"},{"name":"Algorithm","slug":"Programming/Algorithm","permalink":"http://xyom.github.io/categories/Programming/Algorithm/"}],"tags":[{"name":"백준 13911 집 구하기","slug":"백준-13911-집-구하기","permalink":"http://xyom.github.io/tags/백준-13911-집-구하기/"}]},{"title":"Database 정규화","slug":"Database 정규화","date":"2017-12-25T09:19:34.119Z","updated":"2017-12-25T09:19:34.119Z","comments":true,"path":"2017/12/25/Database 정규화/","link":"","permalink":"http://xyom.github.io/2017/12/25/Database 정규화/","excerpt":"","text":"Database 정규화1. 데이터베이스 정규화의 목적 삽입, 삭제, 갱신의 이상 현상을 방지한다. -&gt; 이상 현상이란? 데이터의 삽입, 삭제, 갱신을 하면서 불필요한 정보가 삭제되거나 삽입되고 갱신시 일부만 변경되어 데이터의 일관성이 없어지는 현상이다. 삽입 이상: 만약 위와 같은 테이블에 이름과 학번의 정보만 넣고 싶은 경우 주소, 전공, 담당 교수에 대한 정보까지 넣어야한다. Null이 들어가게 되도 불필요한 저장공간을 차지하게 된다. 삭제 이상: 김공대 교수가 은퇴하여 김공대 교수만 삭제하고 싶어 김공대 교수를 담당 교수로 가지게 된 튜플을 삭제하게 되면 불필요한 다른 학생들의 정보까지 삭제된다. 갱신 이상: 컴퓨터공학의 담당교수를 모두 김공대 교수로 바꾸고 싶지만 일괄적으로 갱신이 되지 않을 수 있다. ​ 데이터의 중복을 최소화 한다 정보의 일관성을 보장한다. 2. 데이터 베이스 정규화 데이터베이스의 정규화에는 제1정규형~제5정규형까지 존재한다. 하지만 보통 제 3정규형까지 적용하여 데이터베이스를 설계한다. 제 1정규형 : 도메인이 원자 값 제 1정규형에서 도메인이 원자값이라는 것은 한 도메인에 알맞은 값으로 하나 존재해야 한다는 것을 뜻한다. 위와 같은 테이블에서 과목이라는 테이블을 저장하기 위해 과목 1,과목2,과목 3과 같이 동일한 계열의 컬럼이 여러개로 정의되어 있는 것이나 과목 이라는 컬럼에 {생물1, 생물2, 생물3}와 같이 한번에 여러 값들이 들어갈 수 없고 하나의 값이 들어간다. ​ -&gt; 다음과 같이 과목이라는 컬럼에 자신들의 과목이 하나씩 들어가게 되지만 학번, 이름, 주소 , 전화번호, 학과코드 등 불필요한 정보들이 많이 중복되게 된다. 제 2 정규형 : 완전 함수종속(부분적 함수 종속 제거) 제 1정규형을 만족하는 테이블이고 부분적 함수 종속성을 제거한다. 테이블에 있는 각 요소들을 하나의 결정자에 의해 그 값이 결정되어야 한다. 예를 들어 위의 제 1정규형 테이블을 보면 학번 -&gt; 이름, 주소,학생의 전화번호를 결정하고 학과코드 -&gt; 학과이름을 결정한다. 즉 같은 테이블에서 학번, 학과코드에 의해 부분적으로 결정되는 데이터들이 있으면 이를 다른 테이블로 나눈다. ​ ​ 제 2정규형을 만들면 하나의 테이블에 있는 데이터는 하나의 결정자에 의해 종속되게 된다. (이름,주소,전화번호) -&gt; 학번에 의해 유일하게 결정되게 되고, (학과 이름) -&gt; 학과코드에 의해 결정된다. 또 (수강과목)-&gt; (학번,학과코드)에 의해 결정 되게 된다. 위의 테이블에서 수강과목 테이블에서 학과의 전화번호는 이행적함수 종속성을 설명하기 위해 임의로추가하였다. 제 3정규형 : 이행적 함수 종속성 제거 제 3정규형은 2정규형을 만족하고 이행적 함수 종속성을 제거한다 . 이행적 함수 종속성이란 A-&gt; B 이면 B-&gt;C이게 된다는 조건을 없애는 것이다. 학번을 알면 학과를 알수 있고 학과를 알면 학과의 전화번호를 알 수 있는 것을 말한다. 즉 이렇게 알 수 있는 데이터에 대해서도 정규화를 통해 테이블을 나누게 된다. 제 4정규형: 다치 종속성 제거 제 5정규형: 조인 종속성 제거 3. 역정규화 데이터베이스의 정규화를 하게 되면 테이블이 나뉘는 경우가 많다. 이 경우 데이터의 조회는 조인을 통한 조회를 하게 되는데 방대한 양의 데이터를 조인하게 되면 시스템에 과부하가 걸릴 가능성이 높다. 이를 피하기 위해 나뉘어진 테이블을 다시 하나의 테이블로 합치는 과정이 필요하게 되는데 이를 역정규화라고 한다.","categories":[{"name":"CS","slug":"CS","permalink":"http://xyom.github.io/categories/CS/"},{"name":"Database","slug":"CS/Database","permalink":"http://xyom.github.io/categories/CS/Database/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://xyom.github.io/tags/Database/"}]},{"title":"백준 2661 좋은 수열","slug":"백준-2661-좋은-수열","date":"2017-12-25T08:31:50.701Z","updated":"2017-12-25T08:31:50.701Z","comments":true,"path":"2017/12/25/백준-2661-좋은-수열/","link":"","permalink":"http://xyom.github.io/2017/12/25/백준-2661-좋은-수열/","excerpt":"","text":"백준 2661 좋은 수열 문제는 숫자 1,2,3을 이용하여 수열을 만드는 대신 인접한 수열이 동일한 패턴을 가지면 나쁜 수열에 해당되어 이 나쁜 수열이 아니면서 가장 작은 값을 가지는 수열을 찾아내는 문제이다. 예를 들면 12131212라는 수열을 보면 앞의 7자리 1213121까지는 문제가 없는 수열이지만 뒤에 2라는 숫자가 오게되므로 12/12라는 동일한 패턴이 인접해서 발생하므로 나쁜수열이다. 12/12 사이에 3이라는 숫자가 오는 방법으로 121312312 가 되게되면 121/ 312/ 312로 다시 반복되게 되므로 맨뒤의 2를 3으로 바꾸어 주어야 가장 최소의 수열을 만족한다. 이 수열을 만들어내는 가장 쉬운 방법은 dfs를 통해 1,2,3의 숫자를 차례대로 넣어준 뒤(작은 숫자를 만족하기 위해) 이 넣은 숫자가 좋은 수열을 만족하는지 체크하는 것이다. check 함수에는 먼저 넣은 숫자가 전의 숫자와 같을 경우는 바로 빠져나오도록 false를 리턴해 주게 된다. ex) 11,22,33과 같이 똑같은 숫자가 나오면 나쁜 수열이므로 좋은 수열을 체크하는 과정은 위의 그림에서 12131213이라는 수열을 예제로 설명하겠다. 크기가 1인 수열에 대해서는 수를 넣을때 바로 전의 숫자와 같은지로 벌써 판별했기 때문에 크기가 2일때 부터 시작한다. 숫자는 쌓여지면서 좋은수열을 계속 판단하고 숫자를 넣어가기 때문에 숫자가 붙는 오른쪽을 기준으로 인접한 수열이 같은패턴이 있는지 검사한다. 크기가 2인 패턴의 경우를 확인하기 위해 12/13의 인접한 숫자들을 판별한다. for문을 통해 숫자를 비교하면서 두 패턴이 모두 같은 수로 이루어져 있지 않으니 크기 3으로 넘어간다. 크기가 3인 패턴의 경우도 마찬가지로 크기가 3인 오른쪽의 인접한 131/213의 숫자를 판별한다. 여기도 마찬가지로 두 패턴이 같은 수로 이루여져 있지 않으니 크기 4로 넘어간다. 크기 4에서는 모두 비교해보니 1213/ 1213으로 같은 패턴을 보이므로 좋은 수열이 아님을 알 수 있으므로 false를 리턴하고 후보에서 제외한다. 좋은 수열은 현재까지 만들어온 수열 크기의 1/2까지 하면된다. 크기 5이상부터는 같은 길이가 동등한 패턴이 존재 할 수 없으므로 할필요가 없다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#pragma warning(disable:4996)#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;int n;int arr[81];bool found = false;bool check(int depth)&#123; if (arr[depth] == arr[depth - 1]) // 붙어있으면 안됨 return false; if (depth == 0 || depth == 1 || depth == 2) return true; int max_size = (depth + 1) / 2; for (int i = 2; i &lt;= max_size; i++) &#123; bool ok = false; for (int j = 0; j &lt; i; j++) &#123; if (arr[depth - j] != arr[depth - j - i]) &#123; ok = true; break; &#125; &#125; if (!ok) return false; &#125; return true;&#125;void dfs(int depth)&#123; if (depth == n) &#123; found = true; return; &#125; for (int i = 1; i &lt; 4; i++) &#123; arr[depth] = i; if (check(depth)) &#123; dfs(depth + 1); if (found) break; &#125; &#125;&#125;int main()&#123; //freopen(\"input.txt\", \"r\", stdin); scanf(\"%d\", &amp;n); dfs(0); for (int i = 0; i &lt; n; i++) &#123; printf(\"%d\", arr[i]); &#125; printf(\"\\n\");&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://xyom.github.io/categories/Programming/"},{"name":"Algorithm","slug":"Programming/Algorithm","permalink":"http://xyom.github.io/categories/Programming/Algorithm/"}],"tags":[{"name":"백준 2661 좋은 수열","slug":"백준-2661-좋은-수열","permalink":"http://xyom.github.io/tags/백준-2661-좋은-수열/"}]},{"title":"백준 2579 계단 오르기","slug":"백준 2579 계단오르기","date":"2017-12-24T10:32:05.688Z","updated":"2017-12-24T10:32:05.688Z","comments":true,"path":"2017/12/24/백준 2579 계단오르기/","link":"","permalink":"http://xyom.github.io/2017/12/24/백준 2579 계단오르기/","excerpt":"","text":"백준 2579 계단 오르기는 전형적인 dp 문제이다. 이 문제에서의 조건은 돌을 올라가는데 연속 3개의 계단을 밟을 수 없고 계단을 오를때는 1점프 혹은 2점프밖에 할 수 없다는 것이다. 그리고 마지막 계단에 왔을 때 밟아온 계단의 점수를 최대화 하는 것이 문제이다. 이 문제의 핵심은 연속 3개의 계단을 밟을 수 없다는 것이다. 즉 1 2 3 4 라는 계단이 있을 때 4라는 계단에 도달하기 위해서는 1 -&gt; 3 -&gt; 4 (이전 계단을 밟았을 경우 연속 3개를 밟지 못하므로 무조건 2점프를 뛰어야한다) 2-&gt; 4 (이전 계단을 밟지 않았을 경우 조건에 상관없이 2계단 전까지의 최대합을 더해주면 된다.) 즉 dp [i] = max( dp[i-2] + arr[i], dp[i-3] + arr[i-1]+ arr[i] )라는 점화식으로 최대값을 구할 수 있다. 123456789101112131415161718192021222324252627282930313233343536373839#pragma warning(disable:4996)#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;string.h&gt;#define INF 987654321using namespace std;int n;int arr[301];int dp[301];int max(int a, int b)&#123; return a &gt; b ? a : b;&#125;int main(int argc, char* argv[]) &#123; //freopen(\"input.txt\", \"r\", stdin); scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;arr[i]); for (int i = 1; i &lt;= n; i++) &#123; if (i == 1) dp[1] = arr[1]; if (i == 2) dp[2] = arr[1]+arr[2]; if (i &gt;= 3) dp[i] = max(dp[i - 2] + arr[i], dp[i - 3] + arr[i-1] + arr[i]); &#125; printf(\"%d\\n\", dp[n]); return 0;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://xyom.github.io/categories/Programming/"},{"name":"Algorithm","slug":"Programming/Algorithm","permalink":"http://xyom.github.io/categories/Programming/Algorithm/"}],"tags":[{"name":"백준 2579 계단 오르기","slug":"백준-2579-계단-오르기","permalink":"http://xyom.github.io/tags/백준-2579-계단-오르기/"}]},{"title":"자료구조 - DisJointSet","slug":"DisJointSet","date":"2017-12-24T04:24:45.145Z","updated":"2017-12-24T04:24:45.145Z","comments":true,"path":"2017/12/24/DisJointSet/","link":"","permalink":"http://xyom.github.io/2017/12/24/DisJointSet/","excerpt":"","text":"DisJointSet은 집합을 나타낼 수 있는 간단한 자료구조이다. 집합은 어떠한 원소들이 하나의 공통 요소에 의해 묶여 있다는 것을 말한다. 위의 그림을 보면 p q r s는 X라는 요소에 묶여 있고 1 2 3 4 5 는 Y라는 요소에 묶여 있다. 즉 이를 구현하기 위해 생각해보면 각 원소들은 X나 Y라는 요소를 가리키고 있다고 생각하면 편하게 된다. DisJointSet은 초기 모두 자기 자신을 부모로 가진다(각자 크기가 1인 자신만의 집합을 갖는다). 후에 Union연산을 하는 과정에서 병합되는 부모를 상대방의 부모로 가리키게 되면서 만약 같은 부모를 가리키고 있으면 같은 집합이다로 판단하게 된다. DisJointSet은 Prim이나 Kruskal 알고리즘을 풀이 할 때 유용하다. 각각의 간선들을 이어나가면서 간선의 사이클이 발생시키지 않게 하기 위해서는 집합에 포함된 요소가 또다시 포함되지 않아야 하기 때문에 DisJointSet을 사용한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;malloc.h&gt;using namespace std;class DisJointSet&#123;private: int size = 100; int* arr; void allocate() &#123; arr = (int*) malloc( sizeof(int) * size ); for (int i = 0; i &lt; size; i++) arr[i] = i; &#125; public: DisJointSet() &#123; allocate(); &#125; DisJointSet(int s) &#123; size = s; allocate(); &#125; int getParent(int x) &#123; if (arr[x] == x) return x; else return x = getParent(arr[x]); &#125; void unify(int x, int y) &#123; int parentx = getParent(x); int parenty = getParent(y); if (parentx != parenty) arr[parentx] = parenty; &#125;&#125;;void main()&#123; DisJointSet ds; ds.unify(2, 3); ds.unify(1, 3); printf(\"%d \", ds.getParent(2)); printf(\"%d \", ds.getParent(1));&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://xyom.github.io/categories/Programming/"},{"name":"DataStructure","slug":"Programming/DataStructure","permalink":"http://xyom.github.io/categories/Programming/DataStructure/"}],"tags":[{"name":"DisJointSet","slug":"DisJointSet","permalink":"http://xyom.github.io/tags/DisJointSet/"}]},{"title":"자료구조 - HashTable","slug":"HashTable","date":"2017-12-24T04:24:45.133Z","updated":"2017-12-24T04:24:45.133Z","comments":true,"path":"2017/12/24/HashTable/","link":"","permalink":"http://xyom.github.io/2017/12/24/HashTable/","excerpt":"","text":"HashTable 또는 HashMap이란 키값을 이용하여 값을 저장하는 구조로 키값을 해시함수에 넣어 인덱스로 변환한 후 테이블에 접근해 저장하는 자료구조이다. 해시테이블은 해시함수를 통해 테이블의 인덱스를 계산하고 이 값을 통해 테이블에 직접 접근하기 때문에 O(1)의 빠른 접근시간을 가지고 있다. 위 그림을 보면 왼쪽에 사람의 이름에 해당하는 key 값들이 존재한다. John Smith, Lisa Smith.. 이 값들은 키값이 되고 이 값들은 해시함수를 통해 계산되어 01,02,04와 같은 숫자의 인덱스 번호로 바뀌게 된다. 가장 간단한 문자열에 대한 해시함수를 보자면 각 자리의 아스키 코드 값을 더한 값을 해시값으로 리턴하는 것이다. 하지만 이 asdf fdsa와 같이 구성된 문자가 같은데 순서가 다른 문자에 대해서도 똑같은 값으로 취급되기 때문에 충돌이 많이 일어난다. 따라서 각 자리마다 가중치를 두어서 그 가중치를 곱해준 값을 더해주면 충돌을 조금이나마 줄일 수 있다. 해시 함수에서 가장 문제되는 것은 ‘충돌’이다. 현재까지 나와 있는 해시 함수 계산법들도 완전하게 충돌을 피해갈 수 없다고 한다. 즉 충돌을 허용하되 충돌이 일어나면 어떻게 이 문제를 해결할 것인가를 생각해보아야 한다. 대표적으로 이 해결법에는 probing과 chaining이 있다. 체이닝은 위의 그림과 같이 충돌이 일어나는 값에 대해 링크드 리스트를 이용해 저장해 주는 방법이다. 계산된 해시값에 대해서 충돌이 일어나게 되면 단순히 이어 붙이기만 하면 되기 때문에 구현이 쉽지만 포인터를 통해 간접적으로 계속 찾아나가기 때문에 연속된 메모리 공간에서 해결하는 probing 방식보다는 조금 느리다는 단점이 있다. Probing은 Chaining의 방식과 달리 충돌이 나면 원래 테이블내 공간에서 해결하는 개방적 방법이다. 해시 값이 충돌이 나게되면 어떠한 방법을 통해 다시 해시값을 계산한 후 빈공간을 찾아 저장하는 방식이다. 위의 그림에서는 충돌이 일어나면 (get_hash(key) +2table_size를 통해 +2만큼 된 곳에서 빈 곳을 찾아 저장하였다. 이러한 Linear Probing 방식은 간단하지만 값이 클러스터링될 가능성이 높아 자료가 많아지면 클러스터링 된 곳에서 충돌이 많이 발생할 가능성이 높다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class HashTable&#123;private: vector&lt;vector&lt;string&gt;&gt; table; // 체인을 이용하여 충돌의 문제를 완화한다. int getHash(string s) &#123; int sum = 0; int base = 1; for (int i = 0; i &lt; s.length(); i++) &#123; sum += s[i] * base; base *= 2; &#125; return sum % table.size(); &#125;public: HashTable() &#123; for (int i = 0; i &lt; 1000; i++) &#123; vector&lt;string&gt; chain; table.push_back(chain); &#125; &#125; void setValue(string key,string value) &#123; int index = getHash(key); table[index].push_back(value); &#125; vector&lt;string&gt; getValue(string key) &#123; int index = getHash(key); vector&lt;string&gt; result; for (int i = 0; i &lt; table[index].size(); i++) &#123; result.push_back(table[index][i]); &#125; return result; &#125;&#125;;void main()&#123; ios::sync_with_stdio(false);cin.tie(0); HashTable ht; ht.setValue(\"Value\", \"flow\"); ht.setValue(\"Value\", \"flower\"); ht.setValue(\"Value\", \"falut\"); ht.setValue(\"value\", \"Areo\"); ht.setValue(\"value\", \"Bucket\"); vector&lt;string&gt; result = ht.getValue(\"Value\"); vector&lt;string&gt; result2 = ht.getValue(\"value\"); for (int i = 0; i &lt; result.size(); i++) cout &lt;&lt; result[i]&lt;&lt;endl; for (int i = 0; i &lt; result2.size(); i++) cout &lt;&lt; result2[i] &lt;&lt; endl;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://xyom.github.io/categories/Programming/"},{"name":"DataStructure","slug":"Programming/DataStructure","permalink":"http://xyom.github.io/categories/Programming/DataStructure/"}],"tags":[{"name":"HashTable","slug":"HashTable","permalink":"http://xyom.github.io/tags/HashTable/"}]},{"title":"자료구조 - PriorityQueue","slug":"PriorityQueue","date":"2017-12-24T03:53:25.484Z","updated":"2017-12-24T03:53:25.484Z","comments":true,"path":"2017/12/24/PriorityQueue/","link":"","permalink":"http://xyom.github.io/2017/12/24/PriorityQueue/","excerpt":"","text":"우선순위 큐는 Heap의 구조를 이용해 정렬을 수행하는 이진 트리 구조이다. Heap은 원소를 삽입시 가장 큰 원소가 루트 노드에 오도록 노드의 위치를 재배열한다. 이 재배열을 하는 과정은 매번 O(logn)의 시간복잡도를 가지게 된다. 우선순위 큐를 구현하면서 가장 큰 두가지의 기능인 Push와 Pop의 기능을 생각해보자. Push 연산을 하게 되면 원소는 가장 마지막 Leaf노드의 다음 위치에 삽입되게 된다. 다음 위치에 삽입된 후 부모 노드의 크기 값과 비교하여 만약 부모원소보다 크다면 자리를 바꾸고 이 과정을 반복해 나가게 된다. 결국 가장 큰 원소라면 루트 노드에 위치하게 될 것이고 pop할시 루트 노드의 값을 출력해주기만 하면 된다. pop한뒤 남아 있는 원소들의 정렬에 대해서는 가장 마지막에 위치하는 리프노드의 값을 루트노드로 옮기고 자식노드 들과 비교하여 자식노드가 더 크다면 위치를 바꾸어 준다. 자식이 두개 존재하는 경우 왼쪽, 오른쪽 둘 중 더 큰 자식과 자리를 바꾸어준다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#include &lt;cstdio&gt;#include &lt;stdlib.h&gt;using namespace std;class PriorityQueue&#123;private: int max_size = 10; int size = 0; void allocate() &#123; arr = (int*)malloc( sizeof(int) * max_size ); &#125;public: int* arr; PriorityQueue() &#123; allocate(); &#125; PriorityQueue(int size) &#123; max_size = size; allocate(); &#125; int getLeft(int n) &#123; if (2 * n + 1 &lt; size) return 2 * n + 1; else return -1; &#125; int getRight(int n) &#123; if (2 * n + 2 &lt; size) return 2 * n + 2; else return -1; &#125; int getParent(int n) &#123; return (n - 1) / 2; &#125; bool isFull() &#123; return size == max_size; &#125; bool isEmpty() &#123; return size == 0; &#125; void push(int a) &#123; if (!isFull()) &#123; int current = size; int parent = getParent(current); arr[current] = a; while (arr[current] &gt; arr[parent]) &#123; int temp = arr[current]; arr[current] = arr[parent]; arr[parent] = temp; current = parent; parent = getParent(current); &#125; size++; &#125; &#125; int pop() &#123; int target = arr[0]; arr[0] = arr[--size]; int current = 0; while (true) &#123; int left_child = getLeft(current); int right_child = getRight(current); if (left_child != -1 &amp;&amp; right_child != -1) &#123; if (arr[current] &lt; arr[left_child] || arr[current] &lt; arr[right_child]) &#123; if (arr[left_child] &lt; arr[right_child]) &#123; int temp = arr[current]; arr[current] = arr[right_child]; arr[right_child] = temp; current = right_child; &#125; else &#123; int temp = arr[current]; arr[current] = arr[left_child]; arr[left_child] = temp; current = left_child; &#125; &#125; else break; &#125; else if (left_child != -1) &#123; if (arr[current] &lt; arr[left_child]) &#123; int temp = arr[current]; arr[current] = arr[left_child]; arr[left_child] = temp; current = left_child; &#125; else break; &#125; else &#123; break; &#125; &#125; return target; &#125;&#125;;void main()&#123; PriorityQueue pq; pq.push(324); pq.push(532); pq.push(3); pq.push(1023); pq.push(84); pq.push(23); pq.push(5); while (!pq.isEmpty()) &#123; printf(\"%d \", pq.pop()); &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://xyom.github.io/categories/Programming/"},{"name":"DataStructure","slug":"Programming/DataStructure","permalink":"http://xyom.github.io/categories/Programming/DataStructure/"}],"tags":[{"name":"PriorityQueue","slug":"PriorityQueue","permalink":"http://xyom.github.io/tags/PriorityQueue/"}]},{"title":"자료구조 - Stack","slug":"Stack","date":"2017-12-24T03:53:06.104Z","updated":"2017-12-24T03:53:06.104Z","comments":true,"path":"2017/12/24/Stack/","link":"","permalink":"http://xyom.github.io/2017/12/24/Stack/","excerpt":"","text":"Stack은 Last In-First Out의 자료구조로 가장 나중에 들어온 원소가 가장 먼저 나오게되는 자료구조이다. Stack은 top이라는 포인터 변수를 두어서 push, pop하며 이 top포인터를 조절하도록 구현된다. Stack 자료구조는 주로 재귀 호출에 주로 사용되게 되고 재귀 호출로 불린 함수는 가장 나중에 불린 함수가 가장 먼저 실행되는 순서를 가지게 된다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdio&gt;#include &lt;stdlib.h&gt;using namespace std;class Stack&#123;private: int top = -1; int max_size; int *arr; void allocate() &#123; arr = (int*)malloc(sizeof(int) * max_size); &#125;public: Stack() &#123; max_size = 10; allocate(); &#125;; Stack(int size) &#123; max_size = size; allocate(); &#125;; bool isFull() &#123; return top == max_size ? true : false; &#125; bool isEmpty() &#123; return top == -1 ? true : false; &#125; void push(int a) &#123; top++; arr[top] = a; &#125; int pop() &#123; return arr[top--]; &#125;&#125;;void main()&#123; Stack s1; for (int i = 0; i &lt; 10; i++) &#123; s1.push(i); &#125; while (!s1.isEmpty()) &#123; printf(\"%d \", s1.pop()); &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://xyom.github.io/categories/Programming/"},{"name":"DataStructure","slug":"Programming/DataStructure","permalink":"http://xyom.github.io/categories/Programming/DataStructure/"}],"tags":[{"name":"Stack","slug":"Stack","permalink":"http://xyom.github.io/tags/Stack/"}]},{"title":"자료구조 - Queue","slug":"Queue","date":"2017-12-24T03:52:41.587Z","updated":"2017-12-24T03:52:41.587Z","comments":true,"path":"2017/12/24/Queue/","link":"","permalink":"http://xyom.github.io/2017/12/24/Queue/","excerpt":"","text":"Queue는 First in First out의 자료구조로 가장 먼저 들어온 원소가 가장 먼저나가는 선입선출 구조이다. 순서대로 처리해야 할 일을 큐에 집어 넣고 처리할 때 주로 사용되며 알고리즘에서 BFS를 주로 큐를 이용해 구현한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;cstdio&gt;#include&lt;stdlib.h&gt;#define INF -987654321using namespace std;//순환하는 array큐class Queue&#123;private: int max_size = 11; int *arr; int front = 0; int rear = 0; void allocate() &#123; arr = (int *)malloc(sizeof(int) * max_size); &#125;public: Queue() &#123; allocate(); &#125; Queue(int size) &#123; max_size = size + 1; // 큐를 원형큐로 구현할 시 프론트와 레어로 꽉찬 상태를 구별하기 위해서 사이즈를 1만큼 사용하지 못하므로 +1한 값을 최대사이즈로 해준다. allocate(); &#125; bool isEmpty() &#123; return front == rear ? true : false; &#125; bool isFull() &#123; return front == (rear + 1) % max_size ? true : false; &#125; void push(int a) &#123; if (!isFull()) &#123; arr[rear] = a; rear = (rear + 1) % max_size; &#125; else &#123; printf(\"Queue is Fulled\\n\"); &#125; &#125; int pop() &#123; if (!isEmpty()) &#123; int item = arr[front]; front = (front + 1) % max_size; return item; &#125; else &#123; return -INF; &#125; &#125;&#125;;void main()&#123; Queue q1; int push[20] = &#123; 12, 13, 15, 16, 201, 356, 23, 76, 45, 34, 23, 23, 35, 23, 35, 46, 78, 89, 90, 21 &#125;; int index = 0; while (index != 20) &#123; while (!q1.isFull()) &#123; q1.push(push[index]); index++; &#125; while (!q1.isEmpty()) &#123; printf(\"%d \", q1.pop()); &#125; &#125; &#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://xyom.github.io/categories/Programming/"},{"name":"DataStructure","slug":"Programming/DataStructure","permalink":"http://xyom.github.io/categories/Programming/DataStructure/"}],"tags":[{"name":"Queue","slug":"Queue","permalink":"http://xyom.github.io/tags/Queue/"}]},{"title":"자료구조 - Linked List","slug":"LinkedList","date":"2017-12-24T03:52:28.507Z","updated":"2017-12-24T03:52:28.503Z","comments":true,"path":"2017/12/24/LinkedList/","link":"","permalink":"http://xyom.github.io/2017/12/24/LinkedList/","excerpt":"","text":"Linked List는 노드 들간의 연결된 포인터들로 구성되는 자료구조이다. 배열과 같이 원소가 선형으로 저장된다는 특성이 있지만 배열과는 달리 중간에 원소의 삽입 삭제가 가능하고 중간에 있는 원소에 접근하기 위해서는 Head에서부터 순차적으로 접근해서 찾는 방식을 취할 수 밖에 없다. 배열과 Linked List는 다음과 같은 차이점을 가지고 있다. Linked List 원소에 대한 접근을 Head부터 다음 노드로 순차적으로 찾아가야 하기 때문에 검색시간은 O(n)이다. 원소를 중간에 삽입, 삭제하는 것이 매우쉽다 ( 전 후 노드가 가르키는 포인터를 바꾸어 주면 된다. ) List로 연결된 요소들이 메모리상에 연속적으로 저장되지 않아도 된다. 배열 메모리상에 연속적으로 저장된 공간이므로 첫주소만 알면 상대적인 주소를 계산해 상수시간 O(1)으로 원소에 접근이 가능하다. 원소를 중간에 삽입,삭제하는 것이 어렵다. 연속된 저장공간이기 때문에 배열의 할당크기를 늘려주어야 하고 삽입하는 지점부터의 원소들을 다시 복사해 주어야 한다. 배열은 메모리상에 연속적으로 저장되어 있다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include &lt;cstdio&gt;#include &lt;stdlib.h&gt;#define INF -987654321using namespace std;typedef struct Node&#123; Node* prev; Node* next; int value; Node(int v) &#123; value = v; &#125;&#125;node;class LinkedList&#123;private: Node* head; Node* tail; int size = 0;public: LinkedList() &#123; &#125; int getSize() &#123; return size; &#125; void pushFront(int value) &#123; Node* target = (Node*)malloc(sizeof(Node)); target-&gt;prev = NULL; target-&gt;next = NULL; target-&gt;value = value; if (head == NULL) &#123; head = target; tail = target; &#125; else &#123; head-&gt;prev = target; target-&gt;next = head; head = target; &#125; size++; &#125; void pushBack(int value) &#123; Node* target = (Node*)malloc(sizeof(Node)); target-&gt;value = value; target-&gt;prev = NULL; target-&gt;next = NULL; if (tail == NULL) &#123; head = target; tail = target; &#125; else &#123; tail-&gt;next = target; target-&gt;prev = tail; tail = target; &#125; size++; &#125; void insertAt(int index, int value) &#123; Node* offset = head; bool exist = true; while (index--) &#123; if (offset-&gt;next != NULL) offset = offset-&gt;next; else exist = false; &#125; if (exist) &#123; Node* target = (Node*)malloc(sizeof(Node)); target-&gt;prev = offset-&gt;prev; target-&gt;next = offset; target-&gt;value = value; if (offset-&gt;prev-&gt;next != NULL) offset-&gt;prev-&gt;next = target; offset-&gt;prev = target; size++; &#125; else &#123; printf(\"That Node Not Exist!\\n\"); &#125; &#125; int popFront() &#123; if (head == NULL) &#123; return INF; &#125; else &#123; size--; int value = head-&gt;value; head = head-&gt;next; return value; &#125; &#125; int popBack() &#123; if (tail == NULL) &#123; return INF; &#125; else &#123; size--; int value = tail-&gt;value; tail = tail-&gt;prev; return value; &#125; &#125; &#125;;void main()&#123; LinkedList l1; for (int i = 0; i &lt; 10; i++) l1.pushBack(i); while (l1.getSize() != 0) &#123; if (l1.getSize() % 2 == 0) printf(\"%d \", l1.popBack()); else printf(\"%d \", l1.popFront()); &#125;&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://xyom.github.io/categories/Programming/"},{"name":"DataStructure","slug":"Programming/DataStructure","permalink":"http://xyom.github.io/categories/Programming/DataStructure/"}],"tags":[{"name":"Linked List","slug":"Linked-List","permalink":"http://xyom.github.io/tags/Linked-List/"}]},{"title":"데이터베이스 인덱스","slug":"Database Index","date":"2017-12-15T04:59:05.385Z","updated":"2017-12-15T04:59:05.385Z","comments":true,"path":"2017/12/15/Database Index/","link":"","permalink":"http://xyom.github.io/2017/12/15/Database Index/","excerpt":"","text":"Database Index1. 인덱스란?데이터베이스에서 원하는 데이터를 검색하기 위해서는 Full-Scan, 인덱스를 통한 검색이 가능하다. DB의 데이터는 삽입된 순서로 정렬되지 않은 형태로 물리적으로 저장되기 때문에 인덱스가 없을 경우 Full-Scan을 통해 자료를 찾아야 하는 비용 발생이 생긴다. n의 시간이지만 데이터가 수억 단위를 넘어가면 효율이 매우 떨어지게 된다.2. 클러스터드 인덱스 vs 넌클러스터드 인덱스- 클러스터드 인덱스 : 데이터베이스 테이블에 Only 1개만 지정될 수 있는 인덱스이다. 보통 Primary key로 지정하면 이 컬럼은 자동적으로 클러스터드 인덱스가 되어 물리적으로 자동 정렬된다.클러스터드 인덱스는 정렬되어 있기 때문에 테이블 자체가 인덱스이다.- 넌 클러스터드 인덱스 : 데이터베이스 테이블에 여러개 지정 할 수 있는 인덱스로 보통의 인덱스를 지칭한다. 일반적으로 책을 찾아볼 때 앞의 목차를 통해서 찾아가는 것과 같이 인덱스를 통해 데이터의 위치가 있는 곳을 찾아간다.3. 인덱스의 동작 과정- 데이터베이스의 테이블은 생성시 frm, myd, myi 로 나뉘어 저장되게 된다.- frm : 테이블의 구조가 저장되어 있는파일- myd : 테이블의 실제 데이터가 들어있는 파일- myi : Index 정보가 들어있는 파일 사용자가 DB에서 데이터를 찾기 위해 select * from employee where salary&gt;=3000; 이라는 쿼리를 입력했다고 하자.1. DB는 이 테이블의 myi 파일에 salary에대해 인덱스가 있는지 확인한다.2. 있을 경우 -&gt; DB의 인덱스 파일을 기준으로 데이터블록을 찾는다.없을 경우 -&gt; Full Scan을 통해 조건에 해당하는 컬럼을 모두 검색한다.4. 인덱스의 구조 이진 검색 트리 ​ B tree 인덱스는 데이터의 저장이 B-TREE라는 자료구조로 저장되어 있다. 현재는 B-TREE의 많은 부분이 보완된 B+ TREE가 사용된다. B-TREE는 Balacned Tree의 약자로서 자동으로 균형을 맞추어 검색할 수 있는 트리이다.일반적으로 트리는 검색을 위하여 균형을 맞추는 것이 중요하다. 이진 트리의 경우 일반적으로 검색 속도가 log n 의 시간복잡도를 가지지만 자식이 한쪽으로 편중된 경우 n의 시간을 갖기 때문에 검색속도에 대해서 효율을 얻을 수 없고 트리를 구성하는 비용에 대해 오히려 일반 배열보다 손해를 본다.일반적인 이진 검색 트리는 노드의 자식 수가 2개로 제한된다는 점이 있지만 B-Tree는 자식을 최대 m개 까지 가질 수 있는 m원 탐색 트리를 기반으로 설계되었고 자동으로 균형을 맞추어 준다. B-TREE -&gt; B tree 참고 인덱스는 이렇게 B-Tree의 구조로 구성되어 있어서 루트 -&gt; 브랜치 노드 브랜치 노드 -&gt; 리프 노드의 순으로 검색을 계속해 나간다. 리프노드에 다다르면 해당 key에 대한 물리 데이터의 주소가 저장되어 있어 이를 통해 데이터에 쉽게 찾아 갈 수 있다.4. 인덱스의 장단점- 인덱스의 가장 큰 장점이라고 하면 검색 속도이다. 인덱스를 구성하면 적절한 인덱스를 선택하여 검색했을 때 일반적으로 Full Scan해서 검색하는 것보다 상당히 빠른 검색효율을 보일 수 있다.- 하지만 인덱스는 검색 속도라는 장점을 가진 대신 단점도 많이 가지고 있다.1. 인덱스 파일을 구성하는데에 비용이 들고 용량을 차지 하게된다.-&gt; 실질적으로 데이터가 삽입되면 데이터에 대한 인덱스 또한 추가해주어야 하기 때문에 비용이 들고 이 인덱스 파일을 구성하는데에 용량을 차지하게 된다.#####2. DML(Insert, delete)에 약하다. -&gt;데이터 변경 작업(Insert,delete)가 자주 일어날 경우 인덱스를 재작성해야 한다.-&gt; insert는 data가 저장되어 있는 기존 블록에 여유 공간이 없는 상황에서 그 블록에 새로운 데이터가 입력되어야 할 경우 블록을 새로 할당하고 기존에 있던 블록의 key value들을 옮기는 과정들을 수행하기 때문에 매우 많은 비용을 소모하게 된다. (Index Split)-&gt; delete의 경우 데이터가 삭제되면 인덱스파일은 데이터가 삭제되지 않고 사용되지 않음으로 표시된다. 100만이었던 데이터를 지워 10만개 남았더라도 인덱스는 100만건이 존재하므로 인덱스를 사용해도 수행속도를 기대하기 힘들 수 있다.#####-&gt; update의 경우 인덱스에 update라는 개념이 없으므로 테이블에 update가 발생할 경우 인덱스에는 delete, insert 두가지 작업이 실행되므로 가장 큰 부하를 일으킨다.","categories":[{"name":"CS","slug":"CS","permalink":"http://xyom.github.io/categories/CS/"},{"name":"Database","slug":"CS/Database","permalink":"http://xyom.github.io/categories/CS/Database/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://xyom.github.io/tags/Database/"}]},{"title":"JavaScript 스코프와 클로저","slug":"Closer","date":"2017-12-10T09:30:11.762Z","updated":"2017-12-10T09:30:11.762Z","comments":true,"path":"2017/12/10/Closer/","link":"","permalink":"http://xyom.github.io/2017/12/10/Closer/","excerpt":"","text":"JavaScript 스코프 JavaScript에서 스코프란 변수가 어느 지역에서 유효한 것을 의미하는 중요한 개념이다. JavaScript는 함수를 기반으로 설계 되었기 때문에 기본적으로 함수 레벨의 스코프를 따르게 되는데 이는 C++, JAVA의 변수 유효범위와는 차이를 보인다. 123456789void getArea(bool condition,int x,int y)&#123; if(condition) &#123; int temp = 3; &#125; return temp * x * y;&#125; 123456789function getArea(condition, x, y)&#123; if(condition) &#123; var temp =3; &#125; return temp * x * y;&#125; 첫번째는 C, 두번째는 JavaScript에서의 경우의 함수이다. 위의 결과를 실행하게 된다면 C에서는 당연히 컴파일 에러가 날 것이다. 하지만 Javascript는 문제없이 실행 되고 3 x y라는 결과를 반환한다. C, Java에서는 블록에서 선언한 변수가 블록 내에서 유효한 반면 JavaScript는 함수 레벨 스코프를 가지기 때문에 if 안에서 선언한 temp 변수도 getArea라는 함수에 속하는 변수로 판단된다. 이와 같은 성질은 평소에 C나 JAVA를 해왔던 프로그래머들에게 익숙하지 않은 개념이고 ECMA6부터는 let과 const라는 블록레벨 스코프를 지원한다. let은 우리가 늘 쓰던 지역변수이고 const는 블록레벨 상수 변수이다. 실행 컨텍스트 실행 컨텍스트는 실행가능한 코드가 실행되는 환경이다. 자바스크립트 엔진은 코드를 실행하기 위해 실행에 필요한 여러가지 정보를 알고 있어야 한다. 실행에 필요한 정보는 아래와 같은 것들이 있다. 변수 : 전역 변수, 지역 변수, 매개변수, 객체의 프로퍼티 함수 선언 변수의 유효 범위 this 실행 컨텍스트는 객체와 같이 만들어져서 실행 도중 새로운 컨텍스트(함수)를 만나면 스택을 쌓아 새로운 컨텍스트를 호출한다. 이와 같이 실행 컨텍스트는 스택에 쌓여 호출 되면 쌓이고 실행이 완료되면 pop되는 구조를 가지고 있다. 실행 컨텍스트에는 객체화 하여 3가지의 프로퍼티를 소유한다. VO (변수 , 함수선언, 인자 등) Scope Chain (변수 오브젝트 + 모든 부모의 스코프) this (함수의 호출에 의해 결정되는 this) 스코프 체인 스코프 체인은 일종의 리스트로 함수의 스코프 레퍼런스를 차례로 저장하고 있는 개념이다. 즉 스코프 체인은 현재 실행 컨텍스트의 AO를 선두로 상위 컨텍스트의 AO를 모두 가르키는 레퍼런스 테이블을 만든다. 실행 컨텍스트가 전역일 경우 이는 VO는 유일한 GO(Global Ovject)를 가르키게 된다. 또한 실행 컨텍스트 중 foo()라는 함수가 만나면 스택에 실행 컨텍스트가 쌓이고 foo()의 스코프에 해당하는 변수, 함수선언들에 대한 AO를 만들게 된다. foo()의 스코프 체인은 0번째는 자신의 AO를 가르키고 그다음은 자신의 상위 부모를 가르키게 된다. (만약 부모가 여러명이라면 모든 부모를 가르킬 때 까지 스코프 체인을 이어나간다.) 클로저 클로저는 내부함수가 참조하는 외부함수의 지역변수가 외부함수에 의해 내부함수가 반환된 이후에도 life-cycle이 유지되는 것을 의미한다. 123456789function outerFunc() &#123; var x = 10; var innerFunc = function () &#123; console.log(x); &#125;; return innerFunc;&#125;// 함수 outerFunc를 호출하면 내부 함수 innerFunc가 반환된다. 그리고 함수 outerFunc의 실행 컨텍스트는 소멸한다var inner = outerFunc();inner(); 위의 코드에서 outerFunc()을 호출하여 innerFunc을 받아 전역 변수 inner에 저장하고 inner를 실행한다. 그렇다면 cosole.log(x)에 x가 찍힐까? -&gt; 그렇다 자바 스크립트는 함수 레벨 스코프를 가진다면서 왜 x의 값은 사라지지 않고 내부함수가 이를 참조하여 출력할 수 있을까? 이를 이해하려면 위에서의 실행컨텍스트를 이해하고 있어야 한다. 위의 실행 컨텍스트에서 보면 이를 이해할 수 있다. outerFunc()은 실행 후 실행 컨텍스트에서 종료되어 그 실행 컨텍스트는 없어진다. 하지만 inner function의 스코프 체인이 outerFunc()의 AO를 가르키고 있어 AO 내부의 변수 x에 참조가 가능한 것이다. -&gt; 다시 말하면 실행 컨텍스트는 사라져도 AO는 바로 사라지지 않는다. 자신을 참조하고 있는 개체가 하나이상이라면 AO는 가비지 콜렉터에 의해 소멸되지 않는다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://xyom.github.io/categories/Programming/"},{"name":"JavaScript","slug":"Programming/JavaScript","permalink":"http://xyom.github.io/categories/Programming/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xyom.github.io/tags/JavaScript/"}]},{"title":"Node js request와 cheerio","slug":"Request와 Cheerio","date":"2017-12-10T08:50:21.547Z","updated":"2017-12-10T08:50:21.547Z","comments":true,"path":"2017/12/10/Request와 Cheerio/","link":"","permalink":"http://xyom.github.io/2017/12/10/Request와 Cheerio/","excerpt":"","text":"Request Node js에는 Request라는 모듈이 있어 아주 간단하게 http 요청을 보낼 수 있다. 기본적으로 Node js가 제공하는 http 모듈을 더욱 사용하기 쉽게 만들어 더욱 짧은 줄로 간단하게 http 요청을 보낼 수 있다. 1npm install --save request 먼저 request모듈을 사용하기 위해 npm을 통해 request 모듈을 설치한다. 123456789var request = require('request');var url = 'http://www.google.com';request(url,function(err,res,body)&#123; if(!err &amp;&amp; res.statusCode == 200) console.log(body);&#125;); 기본적으로 get 방식을 통하여 url에 접근하여 응답을 받고 html요소를 log에 출력하는 코드이다. 위와 같은 코드를 실행하게 된다면 예외가 없고 성공적으로 200 코드를 받았을 경우 html을 출력한다. 또한 request.Method() // GET // POST // PUT // DELETE 와 같은 함수를 통해 손쉽게 Rest Api를 호출 할 수 있고 option 객체를 만들어 파라미터에 넘겨 주는 것으로 명시적으로 header, method, data 등을 설정 가능하다. 1234567891011var option = &#123; uri: url, method: 'POST', json: &#123; 'data': data &#125; &#125;;request(option,function(err,res,body)&#123;&#125;); 위와 같은 방법으로 옵션 객체를 만들고 거기에 특정 필드 부분을 추가하여 여러가지 옵션들을 바꿀 수 있다. 이 외에도 file의 stream을 열어 multipart로 전송하여 upload하는 방법도 사용할 수 있는데 이러한 부분은 모두 추상화되어 있는 다른 모듈을 사용하도록 하자 (Multer). Cheerio Request로 Html 형식의 텍스트를 받아왔다면 이를 파싱할 파서가 필요하다. Node js 에는 Cheerio라는 모듈이 존재해서 아주 간단하고 다양한 방법으로 DOM의 Element에 접근할 수 있다. 1npm install --save cheerio 1234567891011var cheerio = request('cheerio');request(url,function(err, res, body)&#123; var $ = cheerio.load(body); var tbody = $('table tbody'); tbody.children().first().text('첫번째 자식'); tbody.childeren().first().next().append('&lt;li class=\"apple\" &gt; Apple&lt;/li&gt;');&#125;); 위의 코드로 cheerio로 모듈을 가져오고 jquery 방식처럼 간편히 접근할 수 있도록 $에 body를 load한 개체를 담는다. 그 후에는 jquery와 비슷한 방식으로 css selector 방식으로 손쉽게 접근 가능하다. ‘table tbody’와 같이 접근했다면 table이라는 element 요소의 밑에 있는 tbody element를 모두 가져와 tbody에 담는다. 위와 같이 element를 지정하는 것이 아니라 class 접근자 . id 접근자 # 모두 사용 가능하다. 위와 같이 조작할 element요소를 찾았다면 그 요소에 대한 속성, 텍스트 값 등을 모두 조작 가능하다. children() -&gt; 현재 요소 밑에 모든 자식들을 찾아준다. first() -&gt; 요소들 중에 가장 첫번째 요소를 찾아준다. text -&gt; text를 얻어오거나 text를 set 한다. -&gt; text안에 value를 넣어주면 set 되고 넣지 않으면 get할 수 있다. next() -&gt; 현재 요소의 다음 형제 요소를 찾는다. append() -&gt; 현재 요소의 자식을 하나 추가한다. ####사이트 : cheerio GitHub","categories":[{"name":"Programming","slug":"Programming","permalink":"http://xyom.github.io/categories/Programming/"},{"name":"Node js","slug":"Programming/Node-js","permalink":"http://xyom.github.io/categories/Programming/Node-js/"}],"tags":[{"name":"Node js","slug":"Node-js","permalink":"http://xyom.github.io/tags/Node-js/"}]},{"title":"프로젝트 관련 질문","slug":"면접( 프로젝트 관련 질문)","date":"2017-12-08T08:47:39.918Z","updated":"2017-12-08T08:47:39.918Z","comments":true,"path":"2017/12/08/면접( 프로젝트 관련 질문)/","link":"","permalink":"http://xyom.github.io/2017/12/08/면접( 프로젝트 관련 질문)/","excerpt":"","text":"프로젝트 관련 질문**만약 해보지 않았던 거라도 지금 내가 알고있는 것으로 지금이라면 어떻게 하겠다고 이야기 하기. 왜 Node js를 사용하였나?? -&gt; 과거에는 각 api를 하나의 jsp 파일로 만들어서 처리하였다. 이는 매우 불편하고 생산성이 떨어졌고 Node js를 사용하면서 생산성이 많이 향상되었다. 또 npm으로 모듈을 쉽게 관리할 수 있었고 single thread에서 비동기 이벤트 방식으로 동작하기 때문에 멀티 쓰레드에서의 복잡한 동기 문제에 대해 덜 신경쓸 수 있었다. -&gt; Node js는 Cpu Bound 작업에 약하다. single thread가 모두 처리하기 때문에 한 작업이 길어질 경우 다른 작업을 처리하지 못해 반환 시간이 길어지게 된다. -&gt; 작업을 나누어 setTimeout을 통해 일정시간 뒤에 작업을 넣는 방식으로 처리하면 이런 문제를 극복할 수 있다. ​ 비동기 처리를 하다보면 Callback hell 문제가 발생할 수 있는데 이를 어떻게 해결할 수 있나?? 프로젝트 당시 이 문제를 만났을 때는 waterfall이라는 라이브러리를 사용하였고 이는 내부적으로 promise로 구현된 것으로 알고 있다. ​ *서비스 규모가 커질 경우에 대해 생각해보았나 -&gt; 서비스 규모가 커지면 요청이 많이 발생해서 Cpu 사용량도 증가하고 DB나 네트워크 I/O도 매우 커질 것이다. 서버가 많은 요구 사항을 처리하다 보면 에러가 일어날 수 있기 때문에 이 일련의 과정을 트랜잭션으로 처리하는 것은 필수 인 것 같다. 그리고 서버 작업을 하면서 Node js로 프로그래밍 하다보니 AWS 상에서 작업해야 할 경우가 많이 생겼다. 단순히 Putty에서 vi를 통해 코딩하는 것은 어려움이 있어서 WebStorm을 이용하여 sftp로 원격접속하여 편집하였다. 팀 프로젝트를 하면서 어려웠던 점이 없었나? -&gt; 서버 개발, 클라이언트 개발을 나누어 하다보니 api의 요청 값과 응답 값들에 대해서 서로 맞추는게 어려웠다. 그래서 PostMan을 이용해서 작성한뒤 문서를 공유했다. TCP/UDP -&gt; TCP는 신뢰성, UDP는 비신뢰성, TCP는 신뢰성 있는 통신을 하기 위해서 handshaking과 흐름제어 , 오류제어를 한다. 그리고 TCP는 네트워크의 과부하를 막기 위해서 혼잡제어도 사용한다.","categories":[{"name":"InterView","slug":"InterView","permalink":"http://xyom.github.io/categories/InterView/"}],"tags":[{"name":"InterView","slug":"InterView","permalink":"http://xyom.github.io/tags/InterView/"}]},{"title":"Node js 동작 원리","slug":"Node js 동작 원리","date":"2017-12-08T08:47:39.898Z","updated":"2017-12-08T08:47:39.898Z","comments":true,"path":"2017/12/08/Node js 동작 원리/","link":"","permalink":"http://xyom.github.io/2017/12/08/Node js 동작 원리/","excerpt":"","text":"Node js 동작 원리 Index1. Node js 란?2. Node js 동작 원리 1. Node js란?Node js 는 구글의 크롬 V8 자바스크립트 엔진을 기반으로 한 고성능 네트워크 서버이다. Single Thread 기반의 Event Loop를 기반으로 하고 있으며 File, Network 등에 대해서 비동기 IO 처리를 하는 서버 미들웨어이다. 또한 Single Thread 이벤트 기반이기 때문에 Multi Thread 프로그래밍에서의 가장 큰 문제점인 자원에 대한 동시접근 문제가 발생하지는 않는다. -&gt; 자원의 접근 순서는 보장할 수 없다.Node js가 Single Thread 기반이기 때문에 Spring과 같은 Multi Thread 방식을 채택하는 서버 프레임워크보다 Context Switching이 적어 빠르다는 것은 맞지 않는 말이라고 한다.Node js 또한 I/O처리에서 내부적으로는 libio의 Thread Pool에 의해 동작하기 때문에 Node js 또한 Disk , DB 접근이 많은 작업에 대해서는 유리하지 않으며 오히려 Servlet이 빠르다고 한다. -&gt; Node js는 I/O 작업이 적은 메시징 작업에서 유리하다.Node js는 JavaScript를 기반으로 하기 때문에 프론트 개발자가 서버까지 개발할 수 있다는 장점과 JSON 사용, npm을 통한 모듈 관리등을 장점으로 하기 때문에 생산성에 대한 부분에서도 상당히 높다.또한 현재 Http 통신에 있어서 JSON 형식을 사용한 데이터 전송이 많아지고 있는데 Node js를 사용하게 되면 이 부분에 대한 코드의 양도 적어지고 다루기가 쉬워진다.Node js가 인기 있는 이유는 수준 높은 실력을 필요로 하던 백엔드 개발에 대해 진입장벽을 낮추어 프론트 엔트의 개발자 또한 빠르게 개발할 수 있다는 것이다. 그리고 node js의 모듈중의 하나인 socket.io는 HTML5의 WebSocket의 단점을 보완해 준다.HTML 5의 웹소켓이 좋은 기술이지만 웹소켓은 브라우져 호환성의 문제가 있다. Socket.io는 웹소켓을 포함해 롱 폴링, 스트림 등의 방식을 모두 추상화 하였기 때문에 브라우져에 상관없이 Socket.io를 통해 푸쉬를 구현할 수 있게 해준다.Node js는 단점 또한 가지고 있는데 하나의 작업 자체가 시간이 많이 걸리면 전체 시스템의 성능이 아주 급격하게 떨어진다. 그래서 CPU bound가 낮은 작업 위주로 개발이 되어야 한다. -&gt; 만약 많은 CPU bound를 가지는 작업이 생긴다면 이를 분할하여 SetTimeOut() 함수 호출을 통해 이벤트 큐에 분할로 넣어주는 방식으로 처리할 수 있다.또한 Node js는 비동기 처리를 기본으로 하기 때문에 여기서 오는 Callback 함수의 중첩(Callback hell) 에 대한 문제도 생긴다. -&gt; waterfall과 같은 라이브러리를 사용해 어느정도 해결할 수 있다.####### 원문 http://bcho.tistory.com/876 2. Node js 동작 원리 Node Js는 기본적으로 V8엔진을 통해 Single Thread로 동작하게 된다. 하지만 Node js의 특성상 비동기식 I/O를 채택하고 있기 때문에 어떠한 I/O가 발생하게 되면 libio의 ThreadPool에 작업을 전달하게 되고 I/O가 완료되게 되면 EventQueue에 CallBack 함수가 쌓이게 된다.1234connection.query('insert into table values('2','3')', function(result,err)&#123; console.log(result);&#125;); 만약 위와 같이 DB Connection을 통해 DB에 쿼리를 날리는 경우가 발생하면 ‘insert ‘문에 대한 DB IO가 발생하게 된다. Node js는 이 작업에 대해 완료될 때 까지 기다리지 않고 다른 작업을 처리하고 있다가 I/O가 완료되면 callback 함수를 EventQueue에 집어 넣는다. EventLoop는 항상 돌고 있다가 V8 엔진의 호출스택이 모두 종료(모든 작업을 실행하고 남아 있는 작업이 없을 경우) EventQueue에서 작업을 꺼내어 처리하게 된다.또한 Node js가 ThreadPool을 사용하는 이유중에 하나는 시스템에서 Non blocking을 지원하지 않아 Blocking이 발생하는 함수에 대해 호출이 일어났을 경우 이를 Thread에 할당해 처리한뒤 i/o작업이끝나면 callback을 리턴해주어 non blocking처럼 작동할 수 있도록 한다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://xyom.github.io/categories/Programming/"},{"name":"Node js","slug":"Programming/Node-js","permalink":"http://xyom.github.io/categories/Programming/Node-js/"}],"tags":[{"name":"Node js","slug":"Node-js","permalink":"http://xyom.github.io/tags/Node-js/"}]},{"title":"Multer를 이용한 파일 올리기","slug":"Multer를 이용한 파일 올리기","date":"2017-12-08T08:47:39.882Z","updated":"2017-12-08T08:47:39.882Z","comments":true,"path":"2017/12/08/Multer를 이용한 파일 올리기/","link":"","permalink":"http://xyom.github.io/2017/12/08/Multer를 이용한 파일 올리기/","excerpt":"","text":"Multer를 이용한 파일 올리기프로젝트 모듈에 multer를 추가한다. 1npm install --save multer Node의 해당 프로젝트로 이동하여 위의 명령어를 입력하고 multer 모듈을 설치한다. 2. 서버의 요청에 사용할 Api를 만든다.12345678910111213141516171819202122232425var express = require(&apos;express&apos;);var multer = require(&apos;multer&apos;);var router = express.Router();var path = require(&apos;path&apos;);const upload = multer(&#123;storage : multer.diskStorage(&#123; destination: function(req,file,cb) &#123; cb(null,&apos;../../static/images/&apos;); &#125;, filename: function(req,file,cb) &#123; cb(null,new Date().valueOf() + path.extname(file.originalname)); &#125;&#125;),&#125;);router.post(&apos;/up&apos;,upload.single(&apos;img&apos;),function(req,res,err)&#123; var originalPath = &apos;yourUrl/images/&apos;; var filename = originalPath + req.file.filename; res.status(200).json(&#123; result : &apos;success&apos;, path : filename &#125;);&#125;); 서버로 요청할 api를 만들어 받은 요청에 대해 multer를 이용하여 이미지를 저장하고 저장된 경로를 반환 해주도록 한다. 라우터에 post 방식으로 up이라는 요청이 들어왔을 경우 upload.single()에 의해 하나의 파일만 받아 저장하게 된다. 여러개를 저장할 경우 upload.array()를 통해 받을 수 있다, 또한 필드명 별로 여러개의 사진을 받을 경우 .fields 메서드를 이용한다. cont upload에는 multer가 저장할 저장 위치를 정해준다. 위에서 multer가 저장할 저장 위치와 파일명에 대해서 명시적으로 지정해주는 것은 multer에 의해 확장자가 자동으로 제거된 이름으로 명명되는 것을 임의로 설정해 주는 것이다. 1const upload = multer(&#123;dest : &apos;images&apos;&#125;); 만약 multer의 파라미터에 간단하게 dest만 넣어주게 되면 multer를 통해 저장된 파일의 이름이 0ax5e4f725… 과같은 문자로 바뀌어 반환되게 된다. 또한 확장자 까지 제거된 상태로 파일이 저장되므로 static 서버에 저장한뒤 단순히 자원의 이름으로만 접근하게 되면 이미지 파일이 바로 보이지 않고 확장자 없는 파일이 다운된다. 3. Client에서의 요청123456789101112131415161718192021$.ajax(&#123; url : uploadURL, type : &quot;POST&quot;, contentType : false, processData : false, cache : false, data : formData, success: function(data) &#123; status.setUrlName(data.path); console.log(data); &#125;, error:function(request, status, error) &#123; console.log(error); &#125; &#125; ); Client에서의 요청은 위와 같이 ajax를 이용해 요청 하였다. 서버에서의 방식과 마찬가지로 POST로 맞춰주고 data: 항목에는 전송할 데이터 파일의 form형 데이터를 넣는다. 12var formData = new FormData();fd.append(&apos;img&apos;, 파일 객체); formData는 위와 같이 formData에 필드명과 함께 파일객체를 넣어주어 ajax로 요청하게 된다. 이와 같은 작업을 같은 도메인 내에서 한다면 문제가 발생하지 않지만 원격으로 떨어진 서버로 요청을 보내게 될 경우 Same-Origin Policy 문제가 발생한다. Cross-Domain 문제는 ajax의 요청을 같은 도메인이 아닌 다른 도메인을 가진 서버로 요청을 보내는 경우에 제약이 걸리는 것이다. (보안적인 문제를 위해 막았다고 한다.) 위 문제에 대해 Jsonp를 이용해 해결할 수 있는데 Jsonp는 script 요소로 요청되는 호출이 보안 정책에 적용되지 않는점을 이용한 것이라고 한다. 서버측에서 해결하는 방법으로는 서버측에서 Cross Domain을 허용해 주면 된다. -&gt; Node js에서는 cors 모듈을 통해 아주 간단하게 해결 할 수 있다. 1npm install --save cors 모듈을 설치하고 123456var cors = require(&apos;cors&apos;);...app.use(cors()); 를 해주면 문제가 해결된다. 웹 쪽 클라이언트를 많이 다루어 보지 않았지만 웹에서는 이러한 문제가 발생할 수 있다는 것을 알고 넘어가도록 해야겠다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://xyom.github.io/categories/Programming/"},{"name":"Node js","slug":"Programming/Node-js","permalink":"http://xyom.github.io/categories/Programming/Node-js/"}],"tags":[{"name":"Node js","slug":"Node-js","permalink":"http://xyom.github.io/tags/Node-js/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-12-08T08:23:44.171Z","updated":"2017-12-08T08:23:44.171Z","comments":true,"path":"2017/12/08/hello-world/","link":"","permalink":"http://xyom.github.io/2017/12/08/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}